private int current Depth ( ) { try { Integer one Based = ( ( Integer ) DEPTH FIELD . get ( this ) ) ; return one Based - NUM ; } catch ( Illegal Access Exception e ) { throw new Assertion Error ( e ) ; } }
protected boolean [ ] dataset Integrity ( boolean nominal Predictor , boolean numeric Predictor , boolean string Predictor , boolean date Predictor , boolean relational Predictor , boolean multi Instance , int class Type , boolean predictor Missing , boolean class Missing ) { print ( STRING ) ; print Attribute Summary ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type ) ; print ( STRING ) ; int num Train = get Num Instances ( ) , num Classes = NUM , missing Level = NUM ; boolean [ ] result = new boolean [ NUM ] ; Instances train = null ; Kernel kernel = null ; try { train = make Test Dataset ( NUM , num Train , nominal Predictor ? get Num Nominal ( ) : NUM , numeric Predictor ? get Num Numeric ( ) : NUM , string Predictor ? get Num String ( ) : NUM , date Predictor ? get Num Date ( ) : NUM , relational Predictor ? get Num Relational ( ) : NUM , num Classes , class Type , multi Instance ) ; if ( missing Level > NUM ) { add Missing ( train , missing Level , predictor Missing , class Missing ) ; } kernel = Kernel . make Copies ( get Kernel ( ) , NUM ) [ NUM ] ; } catch ( Exception ex ) { throw new Error ( STRING + ex . get Message ( ) ) ; } try { Instances train Copy = new Instances ( train ) ; kernel . build Kernel ( train Copy ) ; compare Datasets ( train , train Copy ) ; println ( STRING ) ; result [ NUM ] = BOOL ; } catch ( Exception ex ) { println ( STRING ) ; result [ NUM ] = BOOL ; if ( m Debug ) { println ( STRING ) ; print ( STRING ) ; println ( STRING + ex . get Message ( ) + STRING ) ; println ( STRING ) ; println ( STRING + train . to String ( ) + STRING ) ; } } return result ; }
public static int union Size ( long [ ] x , long [ ] y ) { final int lx = x . length , ly = y . length ; final int min = ( lx < ly ) ? lx : ly ; int i = NUM , res = NUM ; for ( ; i < min ; i ++ ) { res += Long . bit Count ( x [ i ] | y [ i ] ) ; } for ( ; i < lx ; i ++ ) { res += Long . bit Count ( x [ i ] ) ; } for ( ; i < ly ; i ++ ) { res += Long . bit Count ( y [ i ] ) ; } return res ; }
public void test Reverse Order 4 ( ) throws Exception { UUID id = UUID . random UUID ( ) ; Grid Cache Adapter < String , String > cache = grid . internal Cache ( ) ; Grid Cache Context < String , String > ctx = cache . context ( ) ; Grid Cache Test Entry Ex entry 1 = new Grid Cache Test Entry Ex ( ctx , STRING ) ; Grid Cache Test Entry Ex entry 2 = new Grid Cache Test Entry Ex ( ctx , STRING ) ; Grid Cache Version ver 1 = version ( NUM ) ; Grid Cache Version ver 2 = version ( NUM ) ; Grid Cache Version ver 3 = version ( NUM ) ; Grid Cache Mvcc Candidate v3 k 1 = entry 1 . add Local ( NUM , ver 3 , NUM , BOOL , BOOL ) ; Grid Cache Mvcc Candidate v3 k 2 = entry 2 . add Local ( NUM , ver 3 , NUM , BOOL , BOOL ) ; link Candidates ( ctx , v3 k 1 , v3 k 2 ) ; entry 1 . ready Local ( ver 3 ) ; check Local ( v3 k 1 , ver 3 , BOOL , BOOL , BOOL ) ; check Local ( v3 k 2 , ver 3 , BOOL , BOOL , BOOL ) ; Grid Cache Mvcc Candidate v1 k 1 = entry 1 . add Local ( NUM , ver 1 , NUM , BOOL , BOOL ) ; Grid Cache Mvcc Candidate v1 k 2 = entry 2 . add Local ( NUM , ver 1 , NUM , BOOL , BOOL ) ; link Candidates ( ctx , v1 k 1 , v1 k 2 ) ; entry 1 . ready Local ( ver 1 ) ; entry 2 . ready Local ( ver 1 ) ; check Local ( v3 k 1 , ver 3 , BOOL , BOOL , BOOL ) ; check Local ( v3 k 2 , ver 3 , BOOL , BOOL , BOOL ) ; check Local ( v1 k 1 , ver 1 , BOOL , BOOL , BOOL ) ; check Local ( v1 k 2 , ver 1 , BOOL , BOOL , BOOL ) ; Grid Cache Mvcc Candidate v2 k 2 = entry 2 . add Remote ( id , NUM , ver 2 , NUM , BOOL , BOOL ) ; check Remote ( v2 k 2 , ver 2 , BOOL , BOOL ) ; entry 2 . ready Local ( v3 k 2 ) ; check Local ( v3 k 1 , ver 3 , BOOL , BOOL , BOOL ) ; check Local ( v3 k 2 , ver 3 , BOOL , BOOL , BOOL ) ; }
@ Override public void closing OK ( ) { List < Add User Fields . Attribute Spec > specs = new Array List < Add User Fields . Attribute Spec > ( ) ; for ( int i = NUM ; i < m list Model . size ( ) ; i ++ ) { Add User Fields . Attribute Spec a = ( Add User Fields . Attribute Spec ) m list Model . element At ( i ) ; specs . add ( a ) ; } if ( m modify L != null ) { m modify L . set Modified Status ( Add User Fields Customizer . this , BOOL ) ; } m filter . set Attribute Specs ( specs ) ; }
public String to String ( ) { String Buffer text = new String Buffer ( ) ; if ( ( m class Attribute == null ) ) { return STRING ; } try { text . append ( STRING ) ; text . append ( STRING + m kernel . to String ( ) + STRING ) ; for ( int i = NUM ; i < m class Attribute . num Values ( ) ; i ++ ) { for ( int j = i + NUM ; j < m class Attribute . num Values ( ) ; j ++ ) { text . append ( STRING + m class Attribute . value ( i ) + STRING + m class Attribute . value ( j ) + STRING ) ; text . append ( m classifiers [ i ] [ j ] ) ; if ( m fit Logistic Models ) { text . append ( STRING ) ; if ( m classifiers [ i ] [ j ] . m logistic == null ) { text . append ( STRING ) ; } else { text . append ( m classifiers [ i ] [ j ] . m logistic ) ; } } text . append ( STRING ) ; } } } catch ( Exception e ) { return STRING ; } return text . to String ( ) ; }
public final Sector union ( Sector that ) { if ( that == null ) return this ; Angle min Lat = this . min Latitude ; Angle max Lat = this . max Latitude ; Angle min Lon = this . min Longitude ; Angle max Lon = this . max Longitude ; if ( that . min Latitude . degrees < this . min Latitude . degrees ) min Lat = that . min Latitude ; if ( that . max Latitude . degrees > this . max Latitude . degrees ) max Lat = that . max Latitude ; if ( that . min Longitude . degrees < this . min Longitude . degrees ) min Lon = that . min Longitude ; if ( that . max Longitude . degrees > this . max Longitude . degrees ) max Lon = that . max Longitude ; return new Sector ( min Lat , max Lat , min Lon , max Lon ) ; }
private static boolean is Double Equal ( double value , double value To Compare ) { return ( Math . abs ( value - value To Compare ) < NUM ) ; }
public void test Int Value Pos ( ) { String a = STRING ; Big Decimal a Number = new Big Decimal ( a ) ; int result = - NUM ; assert True ( STRING , a Number . int Value ( ) == result ) ; }
private void walk ( File directory , int depth , Collection < T > results ) throws IO Exception { check If Cancelled ( directory , depth , results ) ; if ( handle Directory ( directory , depth , results ) ) { handle Directory Start ( directory , depth , results ) ; int child Depth = depth + NUM ; if ( depth Limit < NUM || child Depth <= depth Limit ) { check If Cancelled ( directory , depth , results ) ; File [ ] child Files = filter == null ? directory . list Files ( ) : directory . list Files ( filter ) ; child Files = filter Directory Contents ( directory , depth , child Files ) ; if ( child Files == null ) { handle Restricted ( directory , child Depth , results ) ; } else { for ( File child File : child Files ) { if ( child File . is Directory ( ) ) { walk ( child File , child Depth , results ) ; } else { check If Cancelled ( child File , child Depth , results ) ; handle File ( child File , child Depth , results ) ; check If Cancelled ( child File , child Depth , results ) ; } } } } handle Directory End ( directory , depth , results ) ; } check If Cancelled ( directory , depth , results ) ; }
public static Object [ ] ordinal Array ( Tuple Set tuples , String field ) { return ordinal Array ( tuples , field , Default Literal Comparator . get Instance ( ) ) ; }
public void test Divide Exception Invalid RM ( ) { String a = STRING ; int a Scale = NUM ; String b = STRING ; int b Scale = NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; Big Decimal b Number = new Big Decimal ( new Big Integer ( b ) , b Scale ) ; try { a Number . divide ( b Number , NUM ) ; fail ( STRING ) ; } catch ( Illegal Argument Exception e ) { assert Equals ( STRING , STRING , e . get Message ( ) ) ; } }
@ Override public void dataset Changed ( Dataset Change Event event ) { super . dataset Changed ( event ) ; if ( this . subplots == null ) { return ; } XY Dataset dataset = null ; if ( event . get Dataset ( ) instanceof XY Dataset ) { dataset = ( XY Dataset ) event . get Dataset ( ) ; } for ( XY Plot subplot : this . subplots ) { if ( subplot . index Of ( dataset ) >= NUM ) { subplot . configure Range Axes ( ) ; } } }
public boolean on Schedule As Library ( Config config , Config runtime , I Scheduler scheduler , Packing Plan packing ) { boolean ret = BOOL ; try { scheduler . initialize ( config , runtime ) ; ret = scheduler . on Schedule ( packing ) ; if ( ret ) { ret = Scheduler Utils . set Lib Scheduler Location ( runtime , scheduler , BOOL ) ; } else { LOG . severe ( STRING ) ; } } finally { scheduler . close ( ) ; } return ret ; }
public static boolean is String Type ( Type t ) { return t . equals ( Ref Type . v ( STRING ) ) ; }
public Entry update Or Create Source ( User user , String id , String url , String title , Long mod Time , Long create Time , boolean is Admin , Errors errors ) { if ( user == null ) { Errors . add ( errors , error Messages . error User Is Null ( ) ) ; return null ; } if ( url == null ) { Errors . add ( errors , error Messages . error Url Is Null ( ) ) ; return null ; } Entry source = get Entry By User Id And Url ( user . get Id ( ) , url ) ; if ( source == null ) { if ( url . is Empty ( ) ) { Errors . add ( errors , error Messages . error Url Is Empty ( ) ) ; return null ; } if ( title == null ) { Errors . add ( errors , error Messages . error Title Is Null ( ) ) ; return null ; } if ( title . is Empty ( ) ) { Errors . add ( errors , error Messages . error Title Is Empty ( ) ) ; return null ; } if ( mod Time == null ) { Errors . add ( errors , error Messages . error Mod Time Is Null ( ) ) ; return null ; } if ( create Time == null ) { Errors . add ( errors , error Messages . error Create Time Is Null ( ) ) ; return null ; } if ( id != null && ! id Generator . is Id Well Formed ( id ) ) { Errors . add ( errors , error Messages . error Id Is Invalid ( ) ) ; return null ; } if ( create Time . long Value ( ) > mod Time . long Value ( ) ) { mod Time = create Time ; } if ( url != null ) { url = clean Up Text ( url ) ; } if ( title != null ) { title = clean Up Text ( title ) ; } source = new Entry ( ) ; source . set Db ( db ) ; if ( id == null ) { id = id Generator . get Another Id ( ) ; } source . set Id ( id ) ; source . set Source Url ( url ) ; source . set Source Title ( title ) ; source . set Create Time ( create Time ) ; source . set Type ( Constants . source ) ; source . set User Id ( user . get Id ( ) ) ; db . persist Entry ( source ) ; } else if ( ! can User Modify Entry ( user , source , is Admin ) ) { Errors . add ( errors , error Messages . error User Is Not Entitled To Modify The Source ( ) ) ; return null ; } source . set Mod Time ( mod Time ) ; return source ; }
private void validate Sql Statement ( String sql , int jdbc Statement Index ) { Assert . is True ( String Utils . is Not Blank ( sql ) , STRING + jdbc Statement Index + STRING ) ; }
public static Long [ ] values Of ( long [ ] array ) { Long [ ] dest = new Long [ array . length ] ; for ( int i = NUM ; i < array . length ; i ++ ) { dest [ i ] = Long . value Of ( array [ i ] ) ; } return dest ; }
@ Override public boolean is Trace Enabled ( ) { return logger . is Loggable ( Level . FINEST ) ; }
private static void use Missile ( Player player ) { Stackable Item projectiles Item = null ; if ( player . get Range Weapon ( ) != null ) { projectiles Item = player . get Ammunition ( ) ; } if ( projectiles Item == null ) { projectiles Item = player . get Missile If Not Holding Other Weapon ( ) ; } if ( projectiles Item != null ) { projectiles Item . remove One ( ) ; } }
public Tcp Matcher ( final Network Config config ) { super ( config ) ; }
private int determine Max Level Rec ( int level , Node v ) { int new Level = level ; for ( Edge e = v . get First Out Edge ( ) ; e != null ; e = v . get Next Out Edge ( e ) ) { new Level = Math . max ( new Level , determine Max Level Rec ( level , e . get Target ( ) ) + NUM ) ; } return new Level ; }
protected void request Pass Code Confirmation ( ) { clear Boxes ( ) ; m Pass Code Hdr . set Text ( R . string . pass code reenter your pass code ) ; m Pass Code Hdr Explanation . set Visibility ( View . INVISIBLE ) ; m Confirming Pass Code = BOOL ; }
private void add Worker Failed ( Worker w ) { final Reentrant Lock main Lock = this . main Lock ; main Lock . lock ( ) ; try { if ( w != null ) workers . remove ( w ) ; decrement Worker Count ( ) ; try Terminate ( ) ; } finally { main Lock . unlock ( ) ; } }
public void test Insert 4 ( ) throws SQL Exception { Database Creator . fill Simple Table 1 ( conn ) ; statement . execute ( STRING + Database Creator . SIMPLE TABLE 2 + STRING + Database Creator . SIMPLE TABLE 1 ) ; Result Set r = statement . execute Query ( STRING + Database Creator . SIMPLE TABLE 2 + STRING + Database Creator . SIMPLE TABLE 1 + STRING ) ; r . next ( ) ; assert Equals ( STRING , NUM , r . get Int ( NUM ) ) ; r . close ( ) ; }
private synchronized void put Map Entry ( String local Id , Map Entry entry ) { if ( ! is Local Id ( local Id ) ) { throw new Illegal State Exception ( STRING + local Id + STRING ) ; } JSON Object json = new JSON Object ( ) ; try { json . put ( STRING , entry . retain Count ) ; if ( entry . object Id != null ) { json . put ( STRING , entry . object Id ) ; } } catch ( JSON Exception je ) { throw new Illegal State Exception ( STRING , je ) ; } File file = new File ( disk Path , local Id ) ; if ( ! disk Path . exists ( ) ) { disk Path . mkdirs ( ) ; } try { Parse File Utils . write JSON Object To File ( file , json ) ; } catch ( IO Exception e ) { } }
public void end Element ( String namespace URI , String local Name , String name ) throws org . xml . sax . SAX Exception { if ( m in Entity Ref ) return ; m prefix Map . pop Namespaces ( m elem Context . m current Elem Depth , null ) ; try { final java . io . Writer writer = m writer ; if ( m elem Context . m start Tag Open ) { if ( m tracer != null ) super . fire Start Elem ( m elem Context . m element Name ) ; int n Attrs = m attributes . get Length ( ) ; if ( n Attrs > NUM ) { process Attributes ( m writer , n Attrs ) ; m attributes . clear ( ) ; } if ( m space Before Close ) writer . write ( STRING ) ; else writer . write ( STRING ) ; } else { if ( m cdata Tag Open ) close CDATA ( ) ; if ( should Indent ( ) ) indent ( m elem Context . m current Elem Depth - NUM ) ; writer . write ( STRING ) ; writer . write ( STRING ) ; writer . write ( name ) ; writer . write ( STRING ) ; } } catch ( IO Exception e ) { throw new SAX Exception ( e ) ; } if ( ! m elem Context . m start Tag Open && m do Indent ) { m ispreserve = m preserves . is Empty ( ) ? BOOL : m preserves . pop ( ) ; } m isprevtext = BOOL ; if ( m tracer != null ) super . fire End Elem ( name ) ; m elem Context = m elem Context . m prev ; }
public static void f ( String msg , Object ... args ) { if ( ! allow Wtf ) return ; Stack Trace Element caller = get Caller Stack Trace Element ( ) ; String tag = generate Tag ( caller ) ; if ( s Level > LEVEL FATAL ) { return ; } if ( args . length > NUM ) { msg = String . format ( msg , args ) ; } Log . wtf ( tag , msg ) ; }
public void delete Leaves ( String name ) { for ( int i = NUM ; i < leaves . size ( ) ; i ++ ) { Catalog Tree Leaf leaf = leaves . get ( i ) ; if ( name . equals ( leaf . get Name ( ) ) ) { leaves . remove ( i ) ; } } }
public String to String ( ) { final String Buffer s = new String Buffer ( ) ; final int size = size ( ) ; for ( int i = NUM ; i < size ; i ++ ) s . append ( get Int ( i ) ) ; return s . to String ( ) ; }
protected boolean validate ( final char [ ] component , final int soffset , int eoffset , final Bit Set generous ) { if ( eoffset == - NUM ) { eoffset = component . length - NUM ; } for ( int i = soffset ; i <= eoffset ; i ++ ) { if ( ! generous . get ( component [ i ] ) ) { return BOOL ; } } return BOOL ; }
private void build Pieces ( ) { pieces = new Piece [ path Array . size ( ) ] ; Paint paint = new Paint ( ) ; Matrix matrix = new Matrix ( ) ; Canvas canvas = new Canvas ( ) ; for ( int i = NUM ; i < pieces . length ; i ++ ) { int shadow = Utils . next Int ( Utils . dp 2 px ( NUM ) , Utils . dp 2 px ( NUM ) ) ; Path path = path Array . get ( i ) ; Rect F r = new Rect F ( ) ; path . compute Bounds ( r , BOOL ) ; Bitmap p Bitmap = Utils . create Bitmap Safely ( ( int ) r . width ( ) + shadow * NUM , ( int ) r . height ( ) + shadow * NUM , Bitmap . Config . ARGB 4444 , NUM ) ; if ( p Bitmap == null ) { pieces [ i ] = new Piece ( - NUM , - NUM , null , shadow ) ; continue ; } pieces [ i ] = new Piece ( ( int ) r . left + m Touch Point . x - shadow , ( int ) r . top + m Touch Point . y - shadow , p Bitmap , shadow ) ; canvas . set Bitmap ( pieces [ i ] . bitmap ) ; Bitmap Shader m Bitmap Shader = new Bitmap Shader ( m Bitmap , Shader . Tile Mode . CLAMP , Shader . Tile Mode . CLAMP ) ; matrix . reset ( ) ; matrix . set Translate ( - r . left - offset X + shadow , - r . top - offset Y + shadow ) ; m Bitmap Shader . set Local Matrix ( matrix ) ; paint . reset ( ) ; Path offset Path = new Path ( ) ; offset Path . add Path ( path , - r . left + shadow , - r . top + shadow ) ; paint . set Style ( Paint . Style . FILL ) ; paint . set Shadow Layer ( shadow , NUM , NUM , NUM ) ; canvas . draw Path ( offset Path , paint ) ; paint . set Shadow Layer ( NUM , NUM , NUM , NUM ) ; paint . set Xfermode ( new Porter Duff Xfermode ( Porter Duff . Mode . XOR ) ) ; canvas . draw Path ( offset Path , paint ) ; paint . set Xfermode ( null ) ; paint . set Shader ( m Bitmap Shader ) ; paint . set Alpha ( NUM ) ; canvas . draw Path ( offset Path , paint ) ; } Arrays . sort ( pieces ) ; }
public boolean remove Shutdown Hook ( Thread hook ) { Security Manager sm = System . get Security Manager ( ) ; if ( sm != null ) { sm . check Permission ( Runtime Permission Collection . SHUTDOWN HOOKS PERMISSION ) ; } if ( hook == null ) throw new Null Pointer Exception ( STRING ) ; if ( VM State > NUM ) { throw new Illegal State Exception ( ) ; } synchronized ( hooks List ) { return hooks List . remove ( hook ) ; } }
public boolean bound Scroll ( ) { float cur Scroll = get Stack Scroll ( ) ; float new Scroll = get Bounded Stack Scroll ( cur Scroll ) ; if ( Float . compare ( new Scroll , cur Scroll ) != NUM ) { set Stack Scroll ( new Scroll ) ; return BOOL ; } return BOOL ; }
@ Override public Aggregateable Evaluation aggregate ( Evaluation evaluation ) { m Incorrect += evaluation . incorrect ( ) ; m Correct += evaluation . correct ( ) ; m Unclassified += evaluation . unclassified ( ) ; m Missing Class += evaluation . m Missing Class ; m With Class += evaluation . m With Class ; if ( evaluation . m Confusion Matrix != null ) { double [ ] [ ] new Matrix = evaluation . confusion Matrix ( ) ; if ( new Matrix != null ) { for ( int i = NUM ; i < m Confusion Matrix . length ; i ++ ) { for ( int j = NUM ; j < m Confusion Matrix [ i ] . length ; j ++ ) { m Confusion Matrix [ i ] [ j ] += new Matrix [ i ] [ j ] ; } } } } double [ ] new Class Priors = evaluation . m Class Priors ; if ( new Class Priors != null && m Class Priors != null ) { for ( int i = NUM ; i < this . m Class Priors . length ; i ++ ) { m Class Priors [ i ] = new Class Priors [ i ] ; } } m Class Priors Sum = evaluation . m Class Priors Sum ; m Total Cost += evaluation . total Cost ( ) ; m Sum Err += evaluation . m Sum Err ; m Sum Abs Err += evaluation . m Sum Abs Err ; m Sum Sqr Err += evaluation . m Sum Sqr Err ; m Sum Class += evaluation . m Sum Class ; m Sum Sqr Class += evaluation . m Sum Sqr Class ; m Sum Predicted += evaluation . m Sum Predicted ; m Sum Sqr Predicted += evaluation . m Sum Sqr Predicted ; m Sum Class Predicted += evaluation . m Sum Class Predicted ; m Sum Prior Abs Err += evaluation . m Sum Prior Abs Err ; m Sum Prior Sqr Err += evaluation . m Sum Prior Sqr Err ; m Sum KB Info += evaluation . m Sum KB Info ; double [ ] new Margin Counts = evaluation . m Margin Counts ; if ( new Margin Counts != null ) { for ( int i = NUM ; i < m Margin Counts . length ; i ++ ) { m Margin Counts [ i ] += new Margin Counts [ i ] ; } } m Complexity Statistics Available = evaluation . m Complexity Statistics Available ; m Coverage Statistics Available = evaluation . m Coverage Statistics Available ; m Sum Prior Entropy += evaluation . m Sum Prior Entropy ; m Sum Scheme Entropy += evaluation . m Sum Scheme Entropy ; m Total Size Of Regions += evaluation . m Total Size Of Regions ; m Total Coverage += evaluation . m Total Coverage ; Array List < Prediction > preds To Add = evaluation . m Predictions ; if ( preds To Add != null ) { if ( m Predictions == null ) { m Predictions = new Array List < Prediction > ( ) ; } for ( int i = NUM ; i < preds To Add . size ( ) ; i ++ ) { m Predictions . add ( preds To Add . get ( i ) ) ; } } return this ; }
public void wait For Volumes To Be Visible ( CG Request Params request ) { scan ( request . get Copies ( ) , request . get Rsets ( ) ) ; }
protected void start Additional Services ( final Cache cache , final Map < String , Object > options ) throws Exception { }
public void update View ( ) { if ( f Input Element != null && f Parent Composite != null ) { Indicator View State old State = f State Map . get ( f Input Element ) ; boolean reload = f Files To Reoad . contains ( f Input Element ) ; if ( reload || old State == null ) { Json Object json Object = Droidsafe Plugin Utilities . parse Indicator File ( f Input Element ) ; if ( json Object == null ) return ; f Files To Reoad . remove ( f Input Element ) ; f State = new Indicator View State ( f Input Element , json Object , get Security Spec ( ) , old State ) ; f State Map . put ( f Input Element , f State ) ; } else { f State = old State ; } set Part Name ( f State . indicator Type ) ; show Page ( PAGE VIEWER ) ; f Tree Viewer . set Input ( f State . json Object ) ; if ( f Tree Viewer . get Sorter ( ) == null ) sort By Field ( get Sort By Field ( ) ) ; } else { set Part Name ( DEFAULT PART NAME ) ; } }
@ Override public boolean connection Allowed ( String event Name ) { if ( m listenees . contains Key ( event Name ) ) { return BOOL ; } return BOOL ; }
public boolean is Prefixed ( ) { return name . index Of ( STRING ) >= NUM ; }
public void release Any Connection ( Connection connection ) throws SQL Exception { try { connection . close ( ) ; } catch ( Exception ex ) { throw new Runtime Exception ( ex ) ; } }
public Quick Action View add Actions ( Collection < Action > actions ) { check Shown ( ) ; m Actions . add All ( actions ) ; return this ; }
public void add Series Renderer ( int index , Simple Series Renderer renderer ) { m Renderers . add ( index , renderer ) ; }
public static boolean copy Stream ( Input Stream is , Output Stream os , Copy Listener listener , int buffer Size ) throws IO Exception { int current = NUM ; int total = is . available ( ) ; if ( total <= NUM ) { total = DEFAULT IMAGE TOTAL SIZE ; } final byte [ ] bytes = new byte [ buffer Size ] ; int count ; if ( should Stop Loading ( listener , current , total ) ) return BOOL ; while ( ( count = is . read ( bytes , NUM , buffer Size ) ) != - NUM ) { os . write ( bytes , NUM , count ) ; current += count ; if ( should Stop Loading ( listener , current , total ) ) return BOOL ; } os . flush ( ) ; return BOOL ; }
private float calc Angle ( float value ) { return value / m Data . get Y Value Sum ( ) * NUM ; }
public synchronized void return Buf ( byte [ ] buf ) { if ( buf == null || buf . length > m Size Limit ) { return ; } m Buffers By Last Use . add ( buf ) ; int pos = Collections . binary Search ( m Buffers By Size , buf , BUF COMPARATOR ) ; if ( pos < NUM ) { pos = - pos - NUM ; } m Buffers By Size . add ( pos , buf ) ; m Current Size += buf . length ; trim ( ) ; }
public Char Seq concat ( Char Seq another ) { return new Char Seq ( str + another . str ) ; }
@ Override protected void do Get ( Http Servlet Request req , Http Servlet Response resp ) throws Servlet Exception , IO Exception { resp . set Content Type ( STRING ) ; Print Writer send To Client = resp . get Writer ( ) ; for ( Video v : this . videos ) { send To Client . write ( v . get Name ( ) + STRING + v . get Url ( ) + STRING ) ; } }
protected void notify State Change ( int old State , int new State ) { m State = new State ; if ( old State != new State ) { fire Property Change ( STRING , Integer . value Of ( old State ) , Integer . value Of ( new State ) ) ; } }
public void test Get Order ( ) { assert Equals ( STRING , Big Integer . value Of ( NUM ) , ecps . get Order ( ) ) ; }
private void format And Log Throwable ( Logging Level level , Color color , String msg , Throwable t ) { if ( ! USE COLORS ) { format And Log Throwable ( level , msg , t ) ; return ; } if ( Photon Logger . level . id < level . id ) { return ; } Local Date Time date Time = Local Date Time . now ( ) ; String formatted = format Log Line ( level , date Time , msg ) ; Logging Service . log Throwable ( date Time , t , formatted , color ) ; }
public static String construct Queue Redis Key ( String queue Name , String shard Name , int priority , Pin Later Job State state ) { return String . format ( STRING , PINLATER QUEUE KEY PREFIX , shard Name , queue Name , priority , state . get Value ( ) ) ; }
public static String decode Charset ( String s , String charset ) { if ( s == null ) { return null ; } try { byte buf [ ] = s . get Bytes ( ASCII CHARSET ) ; return ( new String ( buf , NUM , buf . length , charset ) ) ; } catch ( Unsupported Encoding Exception uee ) { return s ; } }
public void add Restricted Domain ( String domain Name ) { if ( String Utils . is Empty ( domain Name ) ) { return ; } if ( restricted Domains == null ) { restricted Domains = new Array List < > ( ) ; } restricted Domains . add ( domain Name ) ; }
Stoppable Read Lock ( Read Write Lock lock , Cancel Criterion stopper ) { this . lock = lock . read Lock ( ) ; this . stopper = stopper ; }
public void testis Auto Increment ( ) { try { assert False ( rsmd . is Auto Increment ( NUM ) ) ; } catch ( SQL Exception e1 ) { fail ( STRING + e1 . get Message ( ) ) ; e1 . print Stack Trace ( ) ; } try { conn . close ( ) ; rsmd . get Schema Name ( NUM ) ; fail ( STRING ) ; } catch ( SQL Exception e ) { } }
private long compute Interface Hash ( ) { long hash = NUM ; Byte Array Output Stream sink = new Byte Array Output Stream ( NUM ) ; try { Message Digest md = Message Digest . get Instance ( STRING ) ; Data Output Stream out = new Data Output Stream ( new Digest Output Stream ( sink , md ) ) ; out . write Int ( INTERFACE HASH STUB VERSION ) ; for ( Method method : remote Methods ) { Method Doc method Doc = method . method Doc ( ) ; out . write UTF ( method Doc . name ( ) ) ; out . write UTF ( Util . method Descriptor Of ( method Doc ) ) ; Class Doc exceptions [ ] = method Doc . thrown Exceptions ( ) ; Arrays . sort ( exceptions , new Class Doc Comparator ( ) ) ; for ( Class Doc ex : exceptions ) { out . write UTF ( Util . binary Name Of ( ex ) ) ; } } out . flush ( ) ; byte hash Array [ ] = md . digest ( ) ; for ( int i = NUM ; i < Math . min ( NUM , hash Array . length ) ; i ++ ) { hash += ( ( long ) ( hash Array [ i ] & NUM ) ) << ( i * NUM ) ; } } catch ( IO Exception e ) { throw new Assertion Error ( e ) ; } catch ( No Such Algorithm Exception e ) { throw new Assertion Error ( e ) ; } return hash ; }
public static void copy ( byte [ ] in , Output Stream out ) throws IO Exception { Assert . not Null ( in , STRING ) ; Assert . not Null ( out , STRING ) ; out . write ( in ) ; }
public boolean is Empty ( ) { return items . is Empty ( ) ; }
private static native boolean render Frame ( int [ ] pixels , long gif File In Ptr , int [ ] meta Data ) ;
private static int encode Text ( Char Sequence msg , int startpos , int count , String Builder sb , int initial Submode ) { String Builder tmp = new String Builder ( count ) ; int submode = initial Submode ; int idx = NUM ; while ( BOOL ) { char ch = msg . char At ( startpos + idx ) ; switch ( submode ) { case SUBMODE ALPHA : if ( is Alpha Upper ( ch ) ) { if ( ch == STRING ) { tmp . append ( ( char ) NUM ) ; } else { tmp . append ( ( char ) ( ch - NUM ) ) ; } } else { if ( is Alpha Lower ( ch ) ) { submode = SUBMODE LOWER ; tmp . append ( ( char ) NUM ) ; continue ; } else if ( is Mixed ( ch ) ) { submode = SUBMODE MIXED ; tmp . append ( ( char ) NUM ) ; continue ; } else { tmp . append ( ( char ) NUM ) ; tmp . append ( ( char ) PUNCTUATION [ ch ] ) ; break ; } } break ; case SUBMODE LOWER : if ( is Alpha Lower ( ch ) ) { if ( ch == STRING ) { tmp . append ( ( char ) NUM ) ; } else { tmp . append ( ( char ) ( ch - NUM ) ) ; } } else { if ( is Alpha Upper ( ch ) ) { tmp . append ( ( char ) NUM ) ; tmp . append ( ( char ) ( ch - NUM ) ) ; break ; } else if ( is Mixed ( ch ) ) { submode = SUBMODE MIXED ; tmp . append ( ( char ) NUM ) ; continue ; } else { tmp . append ( ( char ) NUM ) ; tmp . append ( ( char ) PUNCTUATION [ ch ] ) ; break ; } } break ; case SUBMODE MIXED : if ( is Mixed ( ch ) ) { tmp . append ( ( char ) MIXED [ ch ] ) ; } else { if ( is Alpha Upper ( ch ) ) { submode = SUBMODE ALPHA ; tmp . append ( ( char ) NUM ) ; continue ; } else if ( is Alpha Lower ( ch ) ) { submode = SUBMODE LOWER ; tmp . append ( ( char ) NUM ) ; continue ; } else { if ( startpos + idx + NUM < count ) { char next = msg . char At ( startpos + idx + NUM ) ; if ( is Punctuation ( next ) ) { submode = SUBMODE PUNCTUATION ; tmp . append ( ( char ) NUM ) ; continue ; } } tmp . append ( ( char ) NUM ) ; tmp . append ( ( char ) PUNCTUATION [ ch ] ) ; } } break ; default : if ( is Punctuation ( ch ) ) { tmp . append ( ( char ) PUNCTUATION [ ch ] ) ; } else { submode = SUBMODE ALPHA ; tmp . append ( ( char ) NUM ) ; continue ; } } idx ++ ; if ( idx >= count ) { break ; } } char h = NUM ; int len = tmp . length ( ) ; for ( int i = NUM ; i < len ; i ++ ) { boolean odd = ( i % NUM ) != NUM ; if ( odd ) { h = ( char ) ( ( h * NUM ) + tmp . char At ( i ) ) ; sb . append ( h ) ; } else { h = tmp . char At ( i ) ; } } if ( ( len % NUM ) != NUM ) { sb . append ( ( char ) ( ( h * NUM ) + NUM ) ) ; } return submode ; }
public static boolean is Valid NC Name ( String nc Name ) { if ( nc Name . length ( ) == NUM ) return BOOL ; char ch = nc Name . char At ( NUM ) ; if ( is NC Name Start ( ch ) == BOOL ) return BOOL ; for ( int i = NUM ; i < nc Name . length ( ) ; i ++ ) { ch = nc Name . char At ( i ) ; if ( is NC Name ( ch ) == BOOL ) { return BOOL ; } } return BOOL ; }
public Repeated Field Builder < M Type , B Type , I Type > add Message ( M Type message ) { if ( message == null ) { throw new Null Pointer Exception ( ) ; } ensure Mutable Message List ( ) ; messages . add ( message ) ; if ( builders != null ) { builders . add ( null ) ; } on Changed ( ) ; increment Mod Counts ( ) ; return this ; }
protected void prepare Data Set ( ) { data Set 1 = Arrays . as List ( new String [ ] { STRING , STRING , STRING } ) ; data Set 2 = Arrays . as List ( new String [ ] { STRING , STRING , STRING } ) ; data Set 3 = Arrays . as List ( new String [ ] { STRING , STRING , STRING , STRING } ) ; }
private Service Registrar [ ] build Service Registrar ( ) { int k = NUM ; Service Registrar [ ] proxys = new Service Registrar [ proxy Reg Set . size ( ) ] ; Iterator iter = proxy Reg Set . iterator ( ) ; while ( iter . has Next ( ) ) { Proxy Reg reg = ( Proxy Reg ) iter . next ( ) ; proxys [ k ++ ] = reg . proxy ; } return proxys ; }
private static boolean check Value ( String val ) throws Malformed Object Name Exception { if ( val == null ) throw new Null Pointer Exception ( STRING ) ; final int len = val . length ( ) ; if ( len == NUM ) return BOOL ; final char [ ] s = val . to Char Array ( ) ; final int [ ] result = parse Value ( s , NUM ) ; final int end Value = result [ NUM ] ; final boolean value pattern = result [ NUM ] == NUM ; if ( end Value < len ) throw new Malformed Object Name Exception ( STRING + s [ end Value ] + STRING ) ; return value pattern ; }
protected void recover Primary ( Set excluded Servers ) { if ( pool . get Pool Or Cache Cancel In Progress ( ) != null ) { return ; } final boolean is Debug Enabled = logger . is Debug Enabled ( ) ; if ( queue Connections . get Primary ( ) != null ) { if ( is Debug Enabled ) { logger . debug ( STRING ) ; } return ; } if ( is Debug Enabled ) { logger . debug ( STRING ) ; } if ( print Recovering Primary ) { logger . info ( Localized Message . create ( Localized Strings . Queue Manager Impl SUBSCRIPTION MANAGER REDUNDANCY SATISFIER PRIMARY ENDPOINT HAS BEEN LOST ATTEMPTIMG TO RECOVER ) ) ; print Recovering Primary = BOOL ; } Queue Connection Impl new Primary = null ; while ( new Primary == null && pool . get Pool Or Cache Cancel In Progress ( ) == null ) { List backups = queue Connections . get Backups ( ) ; new Primary = promote Backup To Primary ( backups ) ; if ( new Primary == null ) { break ; } if ( ! add To Connection List ( new Primary , BOOL ) ) { synchronized ( lock ) { queue Connections = queue Connections . remove Connection ( new Primary ) ; } new Primary = null ; } } if ( new Primary != null ) { if ( is Debug Enabled ) { logger . debug ( STRING , new Primary . get Endpoint ( ) ) ; } if ( Pool Impl . AFTER PRIMARY RECOVERED CALLBACK FLAG ) { Client Server Observer bo = Client Server Observer Holder . get Instance ( ) ; bo . after Primary Recovered ( new Primary . get Server ( ) ) ; } cqs Connected ( ) ; print Primary Not Found Error = BOOL ; print Recovering Primary = BOOL ; return ; } while ( new Primary == null ) { new Primary = create New Primary ( excluded Servers ) ; if ( new Primary == null ) { break ; } if ( ! add To Connection List ( new Primary , BOOL ) ) { excluded Servers . add ( new Primary . get Server ( ) ) ; new Primary = null ; } if ( new Primary != null ) { if ( is Debug Enabled ) { logger . debug ( STRING , new Primary . get Endpoint ( ) ) ; } if ( ! recover Interest ( new Primary , BOOL ) ) { excluded Servers . add ( new Primary . get Server ( ) ) ; new Primary = null ; } cqs Connected ( ) ; } if ( new Primary != null && Pool Impl . AFTER PRIMARY RECOVERED CALLBACK FLAG ) { Client Server Observer bo = Client Server Observer Holder . get Instance ( ) ; bo . after Primary Recovered ( new Primary . get Server ( ) ) ; } print Primary Not Found Error = BOOL ; print Recovering Primary = BOOL ; return ; } cqs Disconnected ( ) ; if ( is Debug Enabled ) { logger . debug ( STRING ) ; } synchronized ( lock ) { queue Connections = queue Connections . set Primary Discovery Failed ( null ) ; lock . notify All ( ) ; } }
private synchronized void rebuild Journal ( ) throws IO Exception { if ( journal Writer != null ) { journal Writer . close ( ) ; } Writer writer = new Buffered Writer ( new File Writer ( journal File Tmp ) , IO BUFFER SIZE ) ; writer . write ( MAGIC ) ; writer . write ( STRING ) ; writer . write ( VERSION 1 ) ; writer . write ( STRING ) ; writer . write ( Integer . to String ( app Version ) ) ; writer . write ( STRING ) ; writer . write ( Integer . to String ( value Count ) ) ; writer . write ( STRING ) ; writer . write ( STRING ) ; for ( Entry entry : lru Entries . values ( ) ) { if ( entry . current Editor != null ) { writer . write ( DIRTY + STRING + entry . key + STRING ) ; } else { writer . write ( CLEAN + STRING + entry . key + entry . get Lengths ( ) + STRING ) ; } } writer . close ( ) ; journal File Tmp . rename To ( journal File ) ; journal Writer = new Buffered Writer ( new File Writer ( journal File , BOOL ) , IO BUFFER SIZE ) ; }
public void remove ( ) throws Recurrence Info Exception { List < Recurrence Rule > rules List = new Array List < Recurrence Rule > ( ) ; rules List . add All ( r Rules List ) ; rules List . add All ( e Rules List ) ; try { for ( Recurrence Rule rule : rules List ) rule . remove ( ) ; info . remove ( ) ; } catch ( Recurrence Rule Exception rre ) { throw new Recurrence Info Exception ( rre . get Message ( ) , rre ) ; } catch ( Generic Entity Exception gee ) { throw new Recurrence Info Exception ( gee . get Message ( ) , gee ) ; } }
public void add Nodes In Doc Order ( DTM Iterator iterator , X Path Context support ) { if ( ! m mutable ) throw new Runtime Exception ( XSL Messages . create XPATH Message ( XPATH Error Resources . ER NODESETDTM NOT MUTABLE , null ) ) ; int node ; while ( DTM . NULL != ( node = iterator . next Node ( ) ) ) { add Node In Doc Order ( node , support ) ; } }
protected boolean need To Refetch Data ( ) { long now = System . current Time Millis ( ) ; long last = last Data Fetch Time ; if ( ( last + fetch Interval Millis ) < now ) { last Data Fetch Time = now ; return BOOL ; } return BOOL ; }
@ Override public Document Type create Document Type ( String qualified Name , String public ID , String system ID ) { check Q Name ( qualified Name ) ; return new Document Type Impl ( null , qualified Name , public ID , system ID ) ; }
public void handle Request ( Request Context rc ) throws CLI Exception { super . handle Request ( rc ) ; ldap Login ( ) ; SSO Token admin SSO Token = get Admin SSO Token ( ) ; I Output output Writer = get Output Writer ( ) ; String realm = get String Option Value ( I Argument . REALM NAME ) ; String pattern Type = get String Option Value ( I Argument . AGENT TYPE ) ; String filter = get String Option Value ( I Argument . FILTER ) ; if ( pattern Type == null ) { pattern Type = STRING ; } if ( ( filter == null ) || ( filter . length ( ) == NUM ) ) { filter = STRING ; } String [ ] params = { realm , pattern Type , filter } ; write Log ( Log Writer . LOG ACCESS , Level . INFO , STRING , params ) ; try { AM Identity Repository amir = new AM Identity Repository ( admin SSO Token , realm ) ; Id Search Results isr = amir . search Identities ( Id Type . AGENTONLY , filter , new Id Search Control ( ) ) ; Set results = isr . get Search Results ( ) ; if ( ( results != null ) && ! results . is Empty ( ) ) { for ( Iterator i = results . iterator ( ) ; i . has Next ( ) ; ) { AM Identity amid = ( AM Identity ) i . next ( ) ; if ( ! match Type ( amid , pattern Type ) ) { i . remove ( ) ; } } } if ( ( results != null ) && ! results . is Empty ( ) ) { for ( Iterator i = results . iterator ( ) ; i . has Next ( ) ; ) { AM Identity amid = ( AM Identity ) i . next ( ) ; Object [ ] args = { amid . get Name ( ) , amid . get Universal Id ( ) } ; output Writer . println Message ( Message Format . format ( get Resource String ( STRING ) , args ) ) ; } } else { output Writer . println Message ( get Resource String ( STRING ) ) ; } write Log ( Log Writer . LOG ACCESS , Level . INFO , STRING , params ) ; } catch ( Id Repo Exception e ) { String [ ] args = { realm , pattern Type , filter , e . get Message ( ) } ; debug Error ( STRING , e ) ; write Log ( Log Writer . LOG ERROR , Level . INFO , STRING , args ) ; throw new CLI Exception ( e , Exit Codes . REQUEST CANNOT BE PROCESSED ) ; } catch ( SSO Exception e ) { String [ ] args = { realm , pattern Type , filter , e . get Message ( ) } ; debug Error ( STRING , e ) ; write Log ( Log Writer . LOG ERROR , Level . INFO , STRING , args ) ; throw new CLI Exception ( e , Exit Codes . REQUEST CANNOT BE PROCESSED ) ; } }
public byte [ ] to Bytes ( ) { try { Byte Array Output Stream out = new Byte Array Output Stream ( ) ; field . store ( out , null ) ; return out . to Byte Array ( ) ; } catch ( IO Exception e ) { throw new Illegal State Exception ( e ) ; } }
@ HLE Unimplemented @ HLE Function ( nid = NUM , version = NUM , check Inside Interrupt = BOOL ) public int sce Mpeg Next Avc Rp Au ( @ Check Argument ( STRING ) int mpeg , int stream Uid ) { if ( ! stream Map . contains Key ( stream Uid ) ) { log . warn ( String . format ( STRING , stream Uid ) ) ; return - NUM ; } int result = hle Mpeg Get Avc Au ( null ) ; if ( result != NUM ) { if ( log . is Debug Enabled ( ) ) { log . debug ( String . format ( STRING , result ) ) ; } return result ; } video Frame Count ++ ; started Mpeg = BOOL ; return NUM ; }
private Map < URI , Export Mask > create Export Mask Map ( Set < URI > placed Masks ) { Map < URI , Export Mask > export Mask Map = new Hash Map < > ( ) ; Iterator < Export Mask > export Mask Iterator = db Client . query Iterative Objects ( Export Mask . class , placed Masks , BOOL ) ; while ( export Mask Iterator . has Next ( ) ) { Export Mask export Mask = export Mask Iterator . next ( ) ; export Mask Map . put ( export Mask . get Id ( ) , export Mask ) ; } return export Mask Map ; }
public Immutable Array 2 < K > insert ( int index , K obj ) { int len = length + NUM ; int new Len = len ; boolean extendable ; if ( index == len - NUM ) { Atomic Boolean x = can Extend ; if ( x != null ) { can Extend = null ; if ( array . length > index && x . get And Set ( BOOL ) ) { array [ index ] = obj ; return new Immutable Array 2 < K > ( array , len , BOOL ) ; } } extendable = BOOL ; new Len = len + NUM ; } else { extendable = BOOL ; } @ Suppress Warnings ( STRING ) K [ ] a2 = ( K [ ] ) new Object [ new Len ] ; Data Utils . copy With Gap ( array , a2 , length , index ) ; a2 [ index ] = obj ; return new Immutable Array 2 < K > ( a2 , len , extendable ) ; }
public void write No Scale ( Image c , Component i ) { if ( page == null ) { newpage ( ) ; } int x = x0 + width - ( c . get Width ( null ) + charwidth ) ; int y = y0 + ( linenum * lineheight ) + lineascent ; if ( page != null && pagenum >= pr First ) { page . draw Image ( c , x , y , c . get Width ( null ) , c . get Height ( null ) , null ) ; } }
public void put Document In Cache ( int n , Source source ) { int cached Node = get Node ( source ) ; if ( DTM . NULL != cached Node ) { if ( ! ( cached Node == n ) ) throw new Runtime Exception ( STRING + STRING + source . get System Id ( ) ) ; return ; } if ( null != source . get System Id ( ) ) { m source Tree . add Element ( new Source Tree ( n , source . get System Id ( ) ) ) ; } }
private void update Progress ( String progress Label , int progress ) { if ( my Host != null && ( ( progress != previous Progress ) || ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }
public static void copy ( Input Stream is , Resource out , boolean close IS ) throws IO Exception { Output Stream os = null ; try { os = to Buffered Output Stream ( out . get Output Stream ( ) ) ; } catch ( IO Exception ioe ) { IO Util . close EL ( os ) ; throw ioe ; } copy ( is , os , close IS , BOOL ) ; }
public String fade Audio ( String path , String type , double fade In Length , double stop Time , double fade Out Length ) throws IO Exception { final List < String > curves = Arrays . as List ( new String [ ] { STRING , STRING , STRING , STRING , STRING } ) ; if ( ! curves . contains ( type ) ) { throw new Runtime Exception ( STRING + type ) ; } File file = new File ( path ) ; String out File = file . get Canonical Path ( ) + STRING ; Array List < String > cmd = new Array List < String > ( ) ; cmd . add ( sox Bin ) ; cmd . add ( path ) ; cmd . add ( out File ) ; cmd . add ( STRING ) ; cmd . add ( type ) ; cmd . add ( fade In Length + STRING ) ; if ( stop Time != - NUM ) cmd . add ( stop Time + STRING ) ; if ( fade Out Length != - NUM ) cmd . add ( fade Out Length + STRING ) ; try { int rc = exec Sox ( cmd , callback ) ; if ( rc != NUM ) { out File = null ; } } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } return out File ; }
@ Override public void draw ( Canvas canvas ) { super . draw ( canvas ) ; if ( m Edge Glow Top != null ) { final int scroll X = get Scroll X ( ) ; if ( ! m Edge Glow Top . is Finished ( ) ) { final int restore Count = canvas . save ( ) ; final int top Padding = m List Padding . top + m Glow Padding Top ; final int bottom Padding = m List Padding . bottom + m Glow Padding Bottom ; final int height = get Height ( ) - top Padding - bottom Padding ; int edge X = Math . min ( NUM , scroll X + m First Position Distance Guess ) ; canvas . rotate ( - NUM ) ; canvas . translate ( - get Height ( ) + top Padding , edge X ) ; m Edge Glow Top . set Size ( height , height ) ; if ( m Edge Glow Top . draw ( canvas ) ) { invalidate ( ) ; } canvas . restore To Count ( restore Count ) ; } if ( ! m Edge Glow Bottom . is Finished ( ) ) { final int restore Count = canvas . save ( ) ; final int top Padding = m List Padding . left + m Glow Padding Top ; final int bottom Padding = m List Padding . right + m Glow Padding Bottom ; final int height = get Height ( ) - top Padding - bottom Padding ; final int width = get Width ( ) ; int edge X = Math . max ( width , scroll X + m Last Position Distance Guess ) ; canvas . rotate ( NUM ) ; canvas . translate ( - top Padding , - edge X ) ; m Edge Glow Bottom . set Size ( height , height ) ; if ( m Edge Glow Bottom . draw ( canvas ) ) { invalidate ( ) ; } canvas . restore To Count ( restore Count ) ; } } }
public static Class Properties load Properties ( Class [ ] cls , Properties properties , boolean inherit ) { Class Properties cp = new Class Properties ( properties ) ; for ( Class c : cls ) { cp . load ( c , inherit ) ; } return cp ; }
public void test Case 20 ( ) { byte b Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte r Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int b Sign = NUM ; Big Integer a Number = Big Integer . ZERO ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . add ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
private static void fix GPS Time Stamp ( XMP Node exif Schema ) throws XMP Exception { XMP Node gps Date Time = XMP Node Utils . find Child Node ( exif Schema , STRING , BOOL ) ; if ( gps Date Time == null ) { return ; } try { XMP Date Time bin GPS Stamp ; XMP Date Time bin Other Date ; bin GPS Stamp = XMP Utils . convert To Date ( gps Date Time . get Value ( ) ) ; if ( bin GPS Stamp . get Year ( ) != NUM || bin GPS Stamp . get Month ( ) != NUM || bin GPS Stamp . get Day ( ) != NUM ) { return ; } XMP Node other Date = XMP Node Utils . find Child Node ( exif Schema , STRING , BOOL ) ; if ( other Date == null ) { other Date = XMP Node Utils . find Child Node ( exif Schema , STRING , BOOL ) ; } bin Other Date = XMP Utils . convert To Date ( other Date . get Value ( ) ) ; Calendar cal = bin GPS Stamp . get Calendar ( ) ; cal . set ( Calendar . YEAR , bin Other Date . get Year ( ) ) ; cal . set ( Calendar . MONTH , bin Other Date . get Month ( ) ) ; cal . set ( Calendar . DAY OF MONTH , bin Other Date . get Day ( ) ) ; bin GPS Stamp = new XMP Date Time Impl ( cal ) ; gps Date Time . set Value ( XMP Utils . convert From Date ( bin GPS Stamp ) ) ; } catch ( XMP Exception e ) { return ; } }
protected boolean cell Consumes Event Type ( Cell < ? > cell , String event Type ) { Set < String > consumed Events = cell . get Consumed Events ( ) ; return consumed Events != null && consumed Events . contains ( event Type ) ; }
public int read ( ) throws IO Exception { int b0 = f Input Stream . read ( ) ; if ( b0 > NUM ) { throw new IO Exception ( Localizer . get Message ( STRING , Integer . to String ( b0 ) ) ) ; } return b0 ; }
protected void create y axis ( int i ) { Log . e ( STRING , i + STRING ) ; float ver height = ( ( graphheight / label size ) * i ) + border ; if ( i == largest value set . size ( ) - NUM ) canvas . draw Line ( horstart , ver height , width - ( border ) , ver height , paint ) ; else canvas . draw Line ( horstart , ver height , border , ver height , paint ) ; paint . set Color ( Color . BLACK ) ; int Y labels = ( int ) size - NUM - i ; String y labels = String . format ( STRING , Y labels * y axis ratio ) ; paint . set Text Align ( Paint . Align . RIGHT ) ; canvas . draw Text ( y labels , horstart - NUM , ver height - NUM , paint ) ; paint . set Text Align ( Paint . Align . LEFT ) ; }
public long max ( ) { return delta Max . get ( ) ; }
public void print ( File file ) throws IO Exception { check Exec ( ) ; Security Manager sm = System . get Security Manager ( ) ; if ( sm != null ) { sm . check Print Job Access ( ) ; } check Action Support ( Action . PRINT ) ; check File Validation ( file ) ; peer . print ( file ) ; }
public void extend ( Rule Grounding other ) { if ( other . is Failed ( ) ) { groundings . clear ( ) ; return ; } extend ( other . get Alternatives ( ) ) ; }
@ Override public String expect ( Pattern pattern ) { final String token = read ( pattern ) ; if ( token == null ) { throw new Parser Exception ( STRING + pattern . pattern ( ) + STRING + document ) ; } return token ; }
public void test Get Table Types Order ( ) throws Exception { Database Meta Data dmd = con . get Meta Data ( ) ; Result Set rs = dmd . get Table Types ( ) ; String previous Type = STRING ; while ( rs . next ( ) ) { String type = rs . get String ( NUM ) ; assert True ( type . compare To ( previous Type ) >= NUM ) ; previous Type = type ; } rs . close ( ) ; }
private File Channel update Cache ( String file Path ) { File Channel file Channel = file Name And Stream Cache . get ( file Path ) ; try { if ( null == file Channel ) { File Input Stream stream = new File Input Stream ( file Path ) ; file Channel = stream . get Channel ( ) ; file Name And Stream Cache . put ( file Path , file Channel ) ; } } catch ( IO Exception e ) { LOGGER . error ( e , e . get Message ( ) ) ; } return file Channel ; }
public void remove Swipe Listener ( Swipe Listener listener ) { if ( m Listeners == null ) { return ; } m Listeners . remove ( listener ) ; }
