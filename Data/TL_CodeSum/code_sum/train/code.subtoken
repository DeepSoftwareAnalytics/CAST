@ Override public int run Command ( boolean merge Error Into Output , String ... commands ) throws IO Exception , Interrupted Exception { return run Command ( merge Error Into Output , new Array List < String > ( Arrays . as List ( commands ) ) ) ; }
private int find PLV ( int M Price List ID ) { Timestamp price Date = null ; String date Str = Env . get Context ( Env . get Ctx ( ) , p Window No , STRING ) ; if ( date Str != null && date Str . length ( ) > NUM ) price Date = Env . get Context As Date ( Env . get Ctx ( ) , p Window No , STRING ) ; else { date Str = Env . get Context ( Env . get Ctx ( ) , p Window No , STRING ) ; if ( date Str != null && date Str . length ( ) > NUM ) price Date = Env . get Context As Date ( Env . get Ctx ( ) , p Window No , STRING ) ; } if ( price Date == null ) price Date = new Timestamp ( System . current Time Millis ( ) ) ; log . config ( STRING + M Price List ID + STRING + price Date ) ; int ret Value = NUM ; String sql = STRING + STRING + STRING + STRING + STRING + STRING ; try { Prepared Statement pstmt = DB . prepare Statement ( sql , null ) ; pstmt . set Int ( NUM , M Price List ID ) ; Result Set rs = pstmt . execute Query ( ) ; while ( rs . next ( ) && ret Value == NUM ) { Timestamp pl Date = rs . get Timestamp ( NUM ) ; if ( ! price Date . before ( pl Date ) ) ret Value = rs . get Int ( NUM ) ; } rs . close ( ) ; pstmt . close ( ) ; } catch ( SQL Exception e ) { log . log ( Level . SEVERE , sql , e ) ; } Env . set Context ( Env . get Ctx ( ) , p Window No , STRING , ret Value ) ; return ret Value ; }
public static boolean memory Is Low ( ) { return available Memory ( ) * NUM < RUNTIME . total Memory ( ) * NUM ; }
public String describe Attributes ( ) { String Builder sb = new String Builder ( ) ; sb . append ( STRING ) ; boolean first = BOOL ; for ( Object key : attributes . key Set ( ) ) { if ( first ) { first = BOOL ; } else { sb . append ( STRING ) ; } sb . append ( key ) ; sb . append ( STRING ) ; sb . append ( attributes . get ( key ) ) ; } sb . append ( STRING ) ; return sb . to String ( ) ; }
public static byte [ ] next Bytes ( byte [ ] buffer ) { s Random . next Bytes ( buffer ) ; return buffer ; }
public void remove All From Damaged ( final Collection < Unit > damaged Units ) { for ( final Unit u : damaged Units ) { while ( m damaged . contains ( u ) ) { m damaged . remove ( u ) ; } } }
private I Java Element [ ] compute Children ( Array List names Without Extension ) { int size = names Without Extension . size ( ) ; if ( size == NUM ) return NO ELEMENTS ; I Java Element [ ] children = new I Java Element [ size ] ; for ( int i = NUM ; i < size ; i ++ ) { String name Without Extension = ( String ) names Without Extension . get ( i ) ; children [ i ] = new Class File ( this , manager , name Without Extension ) ; } return children ; }
public Object [ ] to Array ( ) { Object [ ] result = new Object [ size ] ; System . arraycopy ( element Data , NUM , result , NUM , size ) ; return result ; }
private static int last Index Of ( Object o , Object [ ] elements , int index ) { if ( o == null ) { for ( int i = index ; i >= NUM ; i -- ) if ( elements [ i ] == null ) return i ; } else { for ( int i = index ; i >= NUM ; i -- ) if ( o . equals ( elements [ i ] ) ) return i ; } return - NUM ; }
public static byte [ ] generate Mac ( byte [ ] byte Cipher Text , Secret Key integrity Key ) throws No Such Algorithm Exception , Invalid Key Exception { Mac sha 256 HMAC = Mac . get Instance ( HMAC ALGORITHM ) ; sha 256 HMAC . init ( integrity Key ) ; return sha 256 HMAC . do Final ( byte Cipher Text ) ; }
@ Override protected void on Delete Complete ( int token , Object cookie , int result ) { if ( token == m Delete Token ) { synchronized ( s Deleting Threads Lock ) { s Deleting Threads = BOOL ; if ( DELETEDEBUG ) { Log . v ( TAG , STRING + s Deleting Threads ) ; } s Deleting Threads Lock . notify All ( ) ; } Unread Badge Service . update ( m Context ) ; Notification Manager . create ( m Context ) ; } }
public static double log 10 ( double val ) { if ( val > NUM ) return Math . log 10 ( val ) ; return HUGE NEGATIVE ; }
private static I Launch Configuration create New Launch Configuration ( I Project project ) throws Core Exception , Operation Canceled Exception { String initial Name = calculate Launch Config Name ( project ) ; I Launch Configuration launch Config = Gwt Super Dev Mode Code Server Launch Util . create Launch Config ( initial Name , project ) ; return launch Config ; }
protected long parse Date ( ) throws IO Exception { if ( utc Calendar == null ) utc Calendar = Calendar . get Instance ( Time Zone . get Time Zone ( STRING ) ) ; return parse Date ( utc Calendar ) ; }
@ Override public Request < List < Builder Status > > builds ( Project Reference project Reference ) { List < Dummy Builder Status > current = current Builder Statuses . get ( project Reference . name ( ) ) ; List < Builder Status > update = new Array List < > ( ) ; if ( current != null ) { for ( Dummy Builder Status dummy Builder Status : current ) { update . add ( dummy Builder Status ) ; } } return new Dummy Request < > ( update ) ; }
public String lookahead ( ) { if ( buf != null ) { return new String ( buf , buf Pos , buf . length - buf Pos ) ; } else { return text . substring ( pos . get Index ( ) ) ; } }
protected int entity Index ( Entity entity ) { return Arrays . binary Search ( entities , entity ) ; }
public void run Test ( ) throws Throwable { Document doc ; Node List element List ; Node name Node ; Character Data child ; doc = ( Document ) load ( STRING , BOOL ) ; element List = doc . get Elements By Tag Name ( STRING ) ; name Node = element List . item ( NUM ) ; child = ( Character Data ) name Node . get First Child ( ) ; { boolean success = BOOL ; try { child . insert Data ( - NUM , STRING ) ; } catch ( DOM Exception ex ) { success = ( ex . code == DOM Exception . INDEX SIZE ERR ) ; } assert True ( STRING , success ) ; } }
public void test Obsolete Dst Zone Name ( ) throws Exception { Simple Date Format format = new Simple Date Format ( STRING , Locale . US ) ; Date normal = format . parse ( STRING ) ; Date dst = format . parse ( STRING ) ; assert Equals ( NUM * NUM * NUM , normal . get Time ( ) - dst . get Time ( ) ) ; }
public abstract boolean is Loggable ( Level level ) ;
public String replace Tokens ( String query String , String replacement , String ... non Replacement Token Prefixes ) { Matcher matcher = token Pattern . matcher ( query String ) ; String Buffer buf = new String Buffer ( ) ; while ( matcher . find ( ) ) { String orig Token = matcher . group ( NUM ) ; if ( orig Token != null ) { matcher . append Replacement ( buf , STRING ) ; if ( token Starts With Prefix ( orig Token , non Replacement Token Prefixes ) ) { buf . append ( STRING + orig Token + STRING ) ; } else { buf . append ( replacement ) ; } } } matcher . append Tail ( buf ) ; return buf . to String ( ) ; }
public boolean is Plural ( ) { return type String . contains ( SUFFIX PLURAL ) ; }
public void insert ( Force Item item ) { try { insert ( item , root , x Min , y Min , x Max , y Max ) ; } catch ( Stack Overflow Error e ) { e . print Stack Trace ( ) ; } }
private void handle Hovering ( int x , int y ) { handle Cell Hover ( x , y ) ; if ( column Headers Visible ) { handle Hover On Column Header ( x , y ) ; } }
public static void draw Circled Text ( Graphics 2 D g , Font font , String text , int x , int y ) { Graphics 2 D g2 = ( Graphics 2 D ) g . create ( ) ; g2 . set Font ( font ) ; Font Metrics fm = g2 . get Font Metrics ( ) ; int padding = NUM ; Rectangle 2 D bounds = fm . get String Bounds ( text , g2 ) ; double th = bounds . get Height ( ) ; double tw = bounds . get Width ( ) ; float radius = ( float ) ( Math . max ( th , tw ) / NUM + padding ) ; Ellipse 2 D . Float circle = new Ellipse 2 D . Float ( x - radius , y - radius , NUM * radius + NUM , NUM * radius + NUM ) ; g2 . fill ( circle ) ; g2 . set Color ( Color . BLACK ) ; g2 . draw String ( text , ( int ) ( x - tw / NUM ) , ( y + fm . get Ascent ( ) / NUM ) ) ; if ( DEBUG ) { g2 . set Color ( Color . RED ) ; g2 . draw Line ( x - NUM , y , x + NUM , y ) ; g2 . draw Line ( x , y - NUM , x , y + NUM ) ; } g2 . dispose ( ) ; }
private void register End ( final String prefix Singular , final String prefix Plural , final String end String ) { prefix End List . add ( new Prefix Entry ( end String , prefix Singular , prefix Plural ) ) ; register Prefix ( prefix Singular , prefix Plural ) ; }
public void add Observer ( Observer observer ) { observers . add ( observer ) ; }
public String to String ( ) { return STRING + subject Public Key Info . to String ( ) + STRING + subject + STRING + STRING + STRING + attribute Set . to String ( ) + STRING ; }
public System Properties Table Model ( ) { column Names = new String [ NUM ] ; column Names [ NUM ] = res . get String ( STRING ) ; column Names [ NUM ] = res . get String ( STRING ) ; data = new Object [ NUM ] [ NUM ] ; }
public static boolean is Simple Match Pattern ( String str ) { return str . index Of ( STRING ) != - NUM ; }
public String read Script ( String fname ) throws IO Exception { String Builder sb = new String Builder ( ) ; Buffered Reader in = null ; try { if ( fname . starts With ( STRING ) || fname . starts With ( STRING ) ) { File System fs = File System . get ( Configuration Manager . get Cached Job Conf ( ) ) ; Path script Path = new Path ( fname ) ; in = new Buffered Reader ( new Input Stream Reader ( fs . open ( script Path ) ) ) ; } else { in = new Buffered Reader ( new File Reader ( fname ) ) ; } String tmp = null ; while ( ( tmp = in . read Line ( ) ) != null ) { sb . append ( tmp ) ; sb . append ( STRING ) ; } } finally { IO Util Functions . close Silently ( in ) ; } return sb . to String ( ) ; }
public static Binary Field Accessor create ( Field field , int id ) { Binary Write Mode mode = Binary Utils . mode ( field . get Type ( ) ) ; switch ( mode ) { case P BYTE : return new Byte Primitive Accessor ( field , id ) ; case P BOOLEAN : return new Boolean Primitive Accessor ( field , id ) ; case P SHORT : return new Short Primitive Accessor ( field , id ) ; case P CHAR : return new Char Primitive Accessor ( field , id ) ; case P INT : return new Int Primitive Accessor ( field , id ) ; case P LONG : return new Long Primitive Accessor ( field , id ) ; case P FLOAT : return new Float Primitive Accessor ( field , id ) ; case P DOUBLE : return new Double Primitive Accessor ( field , id ) ; case BYTE : case BOOLEAN : case SHORT : case CHAR : case INT : case LONG : case FLOAT : case DOUBLE : case DECIMAL : case STRING : case UUID : case DATE : case TIMESTAMP : case BYTE ARR : case SHORT ARR : case INT ARR : case LONG ARR : case FLOAT ARR : case DOUBLE ARR : case CHAR ARR : case BOOLEAN ARR : case DECIMAL ARR : case STRING ARR : case UUID ARR : case DATE ARR : case TIMESTAMP ARR : case ENUM ARR : case OBJECT ARR : case BINARY OBJ : case BINARY : return new Default Final Class Accessor ( field , id , mode , BOOL ) ; default : return new Default Final Class Accessor ( field , id , mode , ! U . is Final ( field . get Type ( ) ) ) ; } }
private String result ( Http URL Connection conn , boolean input ) throws IO Exception { String Buffer sb = new String Buffer ( ) ; if ( input ) { Input Stream is = conn . get Input Stream ( ) ; Buffered Reader reader = new Buffered Reader ( new Input Stream Reader ( is , STRING ) ) ; String line = null ; while ( ( line = reader . read Line ( ) ) != null ) { sb . append ( line ) ; } reader . close ( ) ; is . close ( ) ; } Map < String , Object > result = new Hash Map < String , Object > ( ) ; result . put ( STRING , conn . get Response Code ( ) ) ; result . put ( STRING , conn . get Response Message ( ) ) ; result . put ( STRING , conn . get Content Type ( ) ) ; result . put ( STRING , sb ) ; String output = String . value Of ( conn . get Response Code ( ) ) ; set Output Response Code ( output ) ; Gson gson = new Gson ( ) ; String json = gson . to Json ( result ) ; logger . info ( STRING + json ) ; return json ; }
public boolean is Banned Method ( String sig ) { return banned methods . contains ( sig ) ; }
private Send Return send ( int message Type , String message ) throws Interrupted Exception , Extractor Exception { String length = String . format ( STRING , message . length ( ) ) ; String lenlen = String . format ( STRING , length . length ( ) ) ; String type = String . format ( STRING , message Type ) ; String out Message ; int bytes Read ; String reply String ; int ll ; int t ; Send Return retval = new Send Return ( ) ; boolean length Known ; int total Bytes Read = NUM ; int total Bytes Needed ; boolean long Message Support = BOOL ; if ( ! connected ) throw new Oracle Extract Exception ( STRING ) ; out Message = lenlen + length + type + message ; if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + message Type ) ; logger . debug ( STRING + message ) ; logger . debug ( STRING + out Message ) ; } out . println ( out Message ) ; if ( message Type != Const . Message Control ) { try { if ( long Message Support ) { length Known = BOOL ; total Bytes Read = NUM ; total Bytes Needed = NUM ; for ( ; ; ) { bytes Read = in . read ( reply Buffer , total Bytes Read , reply Buffer Size - total Bytes Read - NUM ) ; if ( bytes Read == - NUM ) { throw new Oracle Extract Exception ( STRING ) ; } total Bytes Read += bytes Read ; logger . debug ( STRING + bytes Read + STRING + total Bytes Read + STRING + total Bytes Needed ) ; if ( length Known ) { if ( total Bytes Read >= total Bytes Needed ) break ; else continue ; } if ( total Bytes Read <= NUM ) continue ; length Known = BOOL ; reply Buffer [ total Bytes Read ] = STRING ; length Buffer [ NUM ] = reply Buffer [ NUM ] ; length Buffer [ NUM ] = reply Buffer [ NUM ] ; length Buffer [ NUM ] = reply Buffer [ NUM ] ; length Buffer [ NUM ] = reply Buffer [ NUM ] ; length Buffer [ NUM ] = reply Buffer [ NUM ] ; length Buffer [ NUM ] = reply Buffer [ NUM ] ; length Buffer [ NUM ] = reply Buffer [ NUM ] ; length Buffer [ NUM ] = reply Buffer [ NUM ] ; length Buffer [ NUM ] = reply Buffer [ NUM ] ; length Buffer [ NUM ] = reply Buffer [ NUM ] ; length Buffer [ NUM ] = STRING ; String length String = new String ( length Buffer ) ; total Bytes Needed = Integer . parse Int ( length String . substring ( NUM , NUM ) , NUM ) ; total Bytes Needed += NUM ; if ( total Bytes Needed + NUM > reply Buffer Size ) increase Reply Buffer ( total Bytes Needed + NUM ) ; if ( total Bytes Read >= total Bytes Needed ) break ; } } else { total Bytes Read = in . read ( reply Buffer ) ; } } catch ( Closed By Interrupt Exception e ) { throw new Interrupted Exception ( STRING ) ; } catch ( IO Exception e ) { throw new Oracle Extract Exception ( STRING ) ; } if ( total Bytes Read == - NUM ) { throw new Oracle Extract Exception ( STRING ) ; } reply Buffer [ total Bytes Read ] = STRING ; reply String = new String ( reply Buffer , NUM , total Bytes Read ) ; if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + reply String + STRING ) ; } ll = Integer . parse Int ( reply String . substring ( NUM , NUM ) ) ; t = Integer . parse Int ( reply String . substring ( NUM + ll , NUM + ll + NUM ) ) ; reply String = reply String . substring ( NUM + ll + NUM ) ; if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + reply String + STRING ) ; } retval . type = t ; retval . reply = reply String ; } else { retval . type = Const . Reply Reserved ; retval . reply = new String ( STRING ) ; } if ( retval . type == Const . Reply Error ) throw new Oracle Extract Exception ( STRING ) ; msg Count ++ ; return retval ; }
private float interpolate ( ) { long curr Time = System . current Time Millis ( ) ; float elapsed = ( curr Time - start Time ) / ZOOM TIME ; elapsed = Math . min ( NUM , elapsed ) ; return interpolator . get Interpolation ( elapsed ) ; }
private void attach Plot ( SVG Plot newplot ) { this . plot = newplot ; if ( newplot == null ) { super . set SVG Document ( null ) ; return ; } newplot . synchronize With ( synchronizer ) ; super . set SVG Document ( newplot . get Document ( ) ) ; super . set Disable Interactions ( newplot . get Disable Interactions ( ) ) ; }
void seek ( int position ) throws IO Exception { m Dex File . seek ( position ) ; }
public E take ( ) throws Interrupted Exception { final Reentrant Lock lock = this . lock ; lock . lock Interruptibly ( ) ; try { for ( ; ; ) { E first = q . peek ( ) ; if ( first == null ) available . await ( ) ; else { long delay = first . get Delay ( NANOSECONDS ) ; if ( delay <= NUM ) return q . poll ( ) ; first = null ; if ( leader != null ) available . await ( ) ; else { Thread this Thread = Thread . current Thread ( ) ; leader = this Thread ; try { available . await Nanos ( delay ) ; } finally { if ( leader == this Thread ) leader = null ; } } } } } finally { if ( leader == null && q . peek ( ) != null ) available . signal ( ) ; lock . unlock ( ) ; } }
public void shutdown ( ) throws Exception { try { if ( solr Client != null ) solr Client . close ( ) ; List < Callable < Jetty Solr Runner > > shutdowns = new Array List < > ( jettys . size ( ) ) ; for ( final Jetty Solr Runner jetty : jettys ) { shutdowns . add ( null ) ; } jettys . clear ( ) ; Collection < Future < Jetty Solr Runner > > futures = executor . invoke All ( shutdowns ) ; Exception shutdown Error = check For Exceptions ( STRING , futures ) ; if ( shutdown Error != null ) { throw shutdown Error ; } } finally { executor . shutdown ( ) ; executor . await Termination ( NUM , Time Unit . SECONDS ) ; try { if ( ! external Zk Server ) { zk Server . shutdown ( ) ; } } finally { System . clear Property ( STRING ) ; } } }
private static Control create Request Control ( final Class clazz , final Class [ ] param Types , final Object [ ] params ) { Constructor constructor = Class Utils . get Constructor If Available ( clazz , param Types ) ; if ( constructor == null ) { Ldap Exception Utils . generate Error Exception ( Ldap Error Codes . ERR 10005 CONTROL CONTRUCTOR NOT FOUND , new String [ ] { clazz . to String ( ) , String Utils . array To Comma Delimited String ( param Types ) } , LOGGER ) ; } Control result = null ; try { result = ( Control ) constructor . new Instance ( params ) ; } catch ( Exception e ) { Ldap Exception Utils . generate Error Exception ( Ldap Error Codes . ERR 10006 CONTROL INSTANCE FAILED , new String [ ] { clazz . to String ( ) , String Utils . array To Comma Delimited String ( param Types ) , String Utils . array To Comma Delimited String ( params ) } , LOGGER , e ) ; } return result ; }
private static boolean is In Corner Target Zone ( float x , float y , float handle X , float handle Y , float target Radius ) { return Math . abs ( x - handle X ) <= target Radius && Math . abs ( y - handle Y ) <= target Radius ; }
public boolean is New State ( ) { return file Name . equals ( STRING ) ; }
public boolean offer ( E e ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { q . offer ( e ) ; if ( q . peek ( ) == e ) { leader = null ; available . signal ( ) ; } return BOOL ; } finally { lock . unlock ( ) ; } }
public void update League History ( ) { Collections . sort ( team List , new Team Comp Poll ( ) ) ; String [ ] year Top 10 = new String [ NUM ] ; Team tt ; for ( int i = NUM ; i < NUM ; ++ i ) { tt = team List . get ( i ) ; year Top 10 [ i ] = tt . abbr + STRING + tt . wins + STRING + tt . losses + STRING ; } league History . add ( year Top 10 ) ; }
public Suffix File Filter ( String [ ] suffixes , IO Case case Sensitivity ) { if ( suffixes == null ) { throw new Illegal Argument Exception ( STRING ) ; } this . suffixes = new String [ suffixes . length ] ; System . arraycopy ( suffixes , NUM , this . suffixes , NUM , suffixes . length ) ; this . case Sensitivity = case Sensitivity == null ? IO Case . SENSITIVE : case Sensitivity ; }
private void update Font ( ) { String font Name = font List . get Value ( ) ; Integer font Size = FALLBACK FONT SIZE ; try { font Size = Integer . parse Int ( font Size List . get Value ( ) ) ; } catch ( Number Format Exception ex ) { } font = new Font ( font Name , Font . PLAIN , font Size ) ; preview . set Font ( font ) ; }
public static Properties read Property File From File System ( final File property File Location ) throws Configuration Exception { final Properties file Properties = new Properties ( ) ; try { final Input Stream input Stream = new File Input Stream ( property File Location ) ; file Properties . load ( input Stream ) ; input Stream . close ( ) ; } catch ( IO Exception e ) { throw new Configuration Exception ( STRING , e ) ; } return file Properties ; }
public void add Translator ( Class Pool cp , Translator t ) throws Not Found Exception , Cannot Compile Exception { source = cp ; translator = t ; t . start ( cp ) ; }
public void test Get Curve ( ) { assert Equals ( STRING , curve , ecps . get Curve ( ) ) ; }
@ Override public void close ( ) throws IO Exception { f Input Stream . close ( ) ; }
public static void sleep ( ) { try { Thread . sleep ( Test Settings . RESPONSE WAIT ) ; } catch ( Interrupted Exception e ) { } }
public void add ( URI uri , Http Cookie cookie ) { if ( cookie == null ) { throw new Null Pointer Exception ( STRING ) ; } lock . lock ( ) ; try { cookie Jar . remove ( cookie ) ; if ( cookie . get Max Age ( ) != NUM ) { cookie Jar . add ( cookie ) ; if ( cookie . get Domain ( ) != null ) { add Index ( domain Index , cookie . get Domain ( ) , cookie ) ; } if ( uri != null ) { add Index ( uri Index , get Effective URI ( uri ) , cookie ) ; } } } finally { lock . unlock ( ) ; } }
public void delete ( Random Access File raf , Random Access File temp Raf ) throws IO Exception , Cannot Write Exception { Flac Tag empty Tag = new Flac Tag ( null , new Array List < Metadata Block Data Picture > ( ) ) ; raf . seek ( NUM ) ; temp Raf . seek ( NUM ) ; write ( empty Tag , raf , temp Raf ) ; }
void show ( Rectangle bounds ) { if ( ! is Created ( ) ) { return ; } if ( log . is Loggable ( Platform Logger . Level . FINER ) ) { log . finer ( STRING + get Window ( ) + STRING + bounds ) ; } X Toolkit . awt Lock ( ) ; try { reshape ( bounds . x , bounds . y , bounds . width , bounds . height ) ; x Set Visible ( BOOL ) ; to Front ( ) ; select Item ( get First Selectable Item ( ) , BOOL ) ; } finally { X Toolkit . awt Unlock ( ) ; } }
void downcase ( final String Buffer text , final int leng ) { for ( int i = NUM ; i < leng ; i ++ ) { if ( Character . is Upper Case ( text . char At ( i ) ) ) { text . set Char At ( i , Character . to Lower Case ( text . char At ( i ) ) ) ; } } }
public int index Of Key ( Object key ) { return key == null ? index Of Null ( ) : index Of ( key , key . hash Code ( ) ) ; }
public void release External Resources ( ) { if ( ! is Closed . get ( ) ) { logger . info ( STRING ) ; Actor Config . shut Down Actor System Force ( ) ; http Client Store . shutdown ( ) ; tcp Ssh Ping Resource Store . shutdown ( ) ; task Manager . clean Wait Task Queue ( ) ; task Manager . clean Inprogress Job Map ( ) ; is Closed . set ( BOOL ) ; logger . info ( STRING + STRING + STRING ) ; } else { logger . debug ( STRING ) ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }
public Batched Image Request ( Request < ? > request , Image Container container ) { m Request = request ; m Containers . add ( container ) ; }
@ Override public I Scan List Iterator < I Entry Cache Info > establish Scan ( K start Pos , short relation , K end Pos , boolean end Pos Inclusive , boolean ordered ) { ordered |= FORCE ORDERED SCAN ; long start Time = recent Extended Index Updates != null ? System . current Time Millis ( ) : NUM ; I Scan List Iterator < I Entry Cache Info > res = ordered ? establish Scan Ordered ( start Pos , relation , end Pos , end Pos Inclusive ) : establish Scan Un Ordered ( start Pos , relation , end Pos , end Pos Inclusive ) ; if ( recent Extended Index Updates != null && ! recent Extended Index Updates . is Empty ( ) ) { Multi Stored List < I Entry Cache Info > msl = new Multi Stored List < I Entry Cache Info > ( ) ; msl . add ( res ) ; msl . add ( recent Extended Index Updates . iterator ( start Time , ( Extended Index Iterator ) res ) ) ; return msl ; } else return res ; }
public static Bytes To Name Canonicalizer create Root ( ) { long now = System . current Time Millis ( ) ; int seed = ( ( ( int ) now ) + ( ( int ) now > > > NUM ) ) | NUM ; return create Root ( seed ) ; }
public void fill Field Values ( List < Synapse Update Rule > rule List ) { Hebbian Rule synapse Ref = ( Hebbian Rule ) rule List . get ( NUM ) ; if ( ! Network Utils . is Consistent ( rule List , Hebbian Rule . class , STRING ) ) { tf Learning Rate . set Text ( Simbrain Constants . NULL STRING ) ; } else { tf Learning Rate . set Text ( Double . to String ( synapse Ref . get Learning Rate ( ) ) ) ; } }
public static int count Argument Placeholders ( final String message Pattern ) { if ( message Pattern == null ) { return NUM ; } final int delim = message Pattern . index Of ( DELIM START ) ; if ( delim == - NUM ) { return NUM ; } int result = NUM ; boolean is Escaped = BOOL ; for ( int i = NUM ; i < message Pattern . length ( ) ; i ++ ) { final char cur Char = message Pattern . char At ( i ) ; if ( cur Char == ESCAPE CHAR ) { is Escaped = ! is Escaped ; } else if ( cur Char == DELIM START ) { if ( ! is Escaped && i < message Pattern . length ( ) - NUM && message Pattern . char At ( i + NUM ) == DELIM STOP ) { result ++ ; i ++ ; } is Escaped = BOOL ; } else { is Escaped = BOOL ; } } return result ; }
protected abstract boolean is End Of Chunk ( char curr Prefix , String curr Label , char next Prefix , String next Label ) ;
public void clear ( ) { set . clear ( ) ; fire Contents Changed ( this , NUM , NUM ) ; }
static String to String ( @ Not Null final Bytes buffer , long position , long len ) throws Buffer Underflow Exception { final long pos = buffer . read Position ( ) ; final long limit = buffer . read Limit ( ) ; buffer . read Position Remaining ( position , len ) ; try { final String Builder builder = new String Builder ( ) ; while ( buffer . read Remaining ( ) > NUM ) { builder . append ( ( char ) buffer . read Byte ( ) ) ; } return builder . to String ( ) ; } finally { buffer . read Limit ( limit ) ; buffer . read Position ( pos ) ; } }
private void init From Auth Header ( String auth Header ) { this . auth Header = auth Header ; if ( auth Header == null ) throw new Null Pointer Exception ( STRING ) ; Matcher auth Matcher = SCHEME PATTERN . matcher ( auth Header ) ; if ( ! auth Matcher . matches ( ) ) { throw new Illegal State Exception ( STRING + auth Header ) ; } scheme = auth Matcher . group ( NUM ) ; if ( auth Matcher . group Count ( ) > NUM ) { Matcher param Matcher = PARAM PATTERN . matcher ( auth Matcher . group ( NUM ) ) ; while ( param Matcher . find ( ) ) { String value = param Matcher . group ( NUM ) ; if ( value == null ) { value = param Matcher . group ( NUM ) ; } parameters . put ( param Matcher . group ( NUM ) , value ) ; } } }
public String to String ( ) { String s = STRING ; Hex Dump Encoder encoder = new Hex Dump Encoder ( ) ; s += encoder . encode Buffer ( octet String ) ; s += STRING ; return ( s ) ; }
public static void add Startup Listener ( Start Up Listener s ) { s startup Listeners . add ( s ) ; }
public void test Write 2 ( ) throws Exception { byte [ ] data = new byte [ ] { - NUM , - NUM , - NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , NUM } ; Test Output Stream tos = new Test Output Stream ( ) ; Cipher Output Stream cos = new Cipher Output Stream ( tos , new Null Cipher ( ) ) ; cos . write ( data ) ; cos . flush ( ) ; byte [ ] result = tos . to Byte Array ( ) ; if ( ! Arrays . equals ( result , data ) ) { fail ( STRING ) ; } try { cos . write ( null ) ; fail ( STRING ) ; } catch ( Null Pointer Exception e ) { } }
@ Visible For Testing static boolean should Open After Download ( Download Info download Info ) { String type = download Info . get Mime Type ( ) ; return download Info . has User Gesture ( ) && ! is Attachment ( download Info . get Content Disposition ( ) ) && MIME TYPES TO OPEN . contains ( type ) ; }
@ Transactional public void save ( final List < Work Flow Matrix > actual Work Flow Matrix Details , final String [ ] departments ) { for ( final String dept : departments ) { for ( final Work Flow Matrix work Flow Matrix : actual Work Flow Matrix Details ) { final Work Flow Matrix wf Obj = work Flow Matrix . clone ( ) ; if ( dept . equals ( DEFAULT ) ) { wf Obj . set Department ( STRING ) ; } else { wf Obj . set Department ( dept ) ; } workflow Matrix Repository . save ( wf Obj ) ; } } }
public void write ( String file ) throws Exception { write ( new File ( file ) ) ; }
private static boolean fields Equal ( Object a , Object b ) { return a == b || ( a != null && a . equals ( b ) ) ; }
private boolean extra Entity ( String output String , int char To Map ) { boolean extra = BOOL ; if ( char To Map < ASCII MAX ) { switch ( char To Map ) { case STRING : if ( ! output String . equals ( STRING ) ) extra = BOOL ; break ; case STRING : if ( ! output String . equals ( STRING ) ) extra = BOOL ; break ; case STRING : if ( ! output String . equals ( STRING ) ) extra = BOOL ; break ; case STRING : if ( ! output String . equals ( STRING ) ) extra = BOOL ; break ; default : extra = BOOL ; } } return extra ; }
public static String quote If Needed ( String s , String delim ) { if ( s == null ) return null ; if ( s . length ( ) == NUM ) return STRING ; for ( int i = NUM ; i < s . length ( ) ; i ++ ) { char c = s . char At ( i ) ; if ( c == STRING || c == STRING || c == STRING || Character . is Whitespace ( c ) || delim . index Of ( c ) >= NUM ) { String Buffer b = new String Buffer ( s . length ( ) + NUM ) ; quote ( b , s ) ; return b . to String ( ) ; } } return s ; }
public static void report ( ) { if ( License . is Developer ( ) ) { for ( final Object obj : SPIES ) { Diagnostic . developer Log ( obj . to String ( ) ) ; } } }
@ Deprecated public void write ( byte b [ ] , int off , int len ) { if ( len < NUM ) throw new Array Index Out Of Bounds Exception ( len ) ; for ( int i = NUM ; i < len ; ++ i ) write ( b [ off + i ] ) ; }
public void or ( Criteria criteria ) { ored Criteria . add ( criteria ) ; }
public final void test Next Bytesbyte Array 03 ( ) throws No Such Algorithm Exception , No Such Provider Exception { Secure Random sr 1 ; Secure Random sr 2 ; byte [ ] my Bytes 1 ; byte [ ] my Bytes 2 ; for ( int i = NUM ; i < LENGTH / NUM ; i += INCR ) { sr 1 = Secure Random . get Instance ( algorithm , provider ) ; sr 2 = Secure Random . get Instance ( algorithm , provider ) ; boolean flag = BOOL ; my Bytes 1 = new byte [ i ] ; my Bytes 2 = new byte [ i ] ; sr 1 . next Bytes ( my Bytes 1 ) ; sr 2 . next Bytes ( my Bytes 2 ) ; for ( int j = NUM ; j < i ; j ++ ) { flag &= my Bytes 1 [ j ] == my Bytes 2 [ j ] ; } sr 1 . next Bytes ( my Bytes 1 ) ; sr 2 . next Bytes ( my Bytes 2 ) ; for ( int j = NUM ; j < i ; j ++ ) { flag &= my Bytes 1 [ j ] == my Bytes 2 [ j ] ; } if ( flag ) { fail ( STRING + i ) ; } } }
public Cursor query ( SQ Lite Database db , String [ ] projection In , String selection , String [ ] selection Args , String group By , String having , String sort Order , String limit ) { if ( m Tables == null ) { return null ; } if ( m Strict && selection != null && selection . length ( ) > NUM ) { String sql For Validation = build Query ( projection In , STRING + selection + STRING , group By , having , sort Order , limit ) ; validate Sql ( db , sql For Validation ) ; } String sql = build Query ( projection In , selection , group By , having , sort Order , limit ) ; return db . raw Query With Factory ( m Factory , sql , selection Args , SQ Lite Database . find Edit Table ( m Tables ) ) ; }
private static String replace Chars ( String str ) { String Buffer buf = new String Buffer ( str ) ; int length = buf . length ( ) ; for ( int i = NUM ; i < length ; i ++ ) { char current Char = buf . char At ( i ) ; if ( current Char == STRING ) { buf . set Char At ( i , STRING ) ; buf . insert ( i + NUM , STRING ) ; length = length + NUM ; i = i + NUM ; } else if ( current Char == STRING ) { buf . set Char At ( i , STRING ) ; } } return buf . to String ( ) ; }
public boolean is Paused ( ) { return BOOL ; }
public Builder trust Certificates ( Key Store trust Store ) throws General Security Exception { SSL Context ssl Context = Ssl Utils . get Tls Ssl Context ( ) ; Ssl Utils . init Ssl Context ( ssl Context , trust Store , Ssl Utils . get Pkix Trust Manager Factory ( ) ) ; return set Ssl Socket Factory ( ssl Context . get Socket Factory ( ) ) ; }
public void reject Re Invite ( int code ) { if ( s Logger . is Activated ( ) ) { s Logger . debug ( STRING ) ; } synchronized ( m Wait User Answer ) { m Re Invite Status = Invitation Status . INVITATION REJECTED ; m Wait User Answer . notify All ( ) ; } }
public static Point parse Point ( String str , Spatial Context ctx ) throws Invalid Shape Exception { try { double x , y ; str = str . trim ( ) ; int comma Idx = str . index Of ( STRING ) ; if ( comma Idx == - NUM ) { int space Idx = str . index Of ( STRING ) ; if ( space Idx == - NUM ) throw new Invalid Shape Exception ( STRING + str ) ; int middle End Idx = find Index Not Space ( str , space Idx + NUM , + NUM ) ; x = Double . parse Double ( str . substring ( NUM , space Idx ) ) ; y = Double . parse Double ( str . substring ( middle End Idx ) ) ; } else { int middle Start Idx = find Index Not Space ( str , comma Idx - NUM , - NUM ) ; int middle End Idx = find Index Not Space ( str , comma Idx + NUM , + NUM ) ; y = Double . parse Double ( str . substring ( NUM , middle Start Idx + NUM ) ) ; x = Double . parse Double ( str . substring ( middle End Idx ) ) ; } x = ctx . norm X ( x ) ; y = ctx . norm Y ( y ) ; return ctx . make Point ( x , y ) ; } catch ( Invalid Shape Exception e ) { throw e ; } catch ( Exception e ) { throw new Invalid Shape Exception ( e . to String ( ) , e ) ; } }
public boolean is Prune ( ) { return prune ; }
public void enqueue Normal ( String method Name , int count ) { Deque < Invocation Handler > handlers = get Handlers ( method Name ) ; for ( int i = NUM ; i < count ; i ++ ) { handlers . add ( delegate Handler ) ; } }
@ Suppress Warnings ( STRING ) @ Override protected Object read Post Process ( Object o ) throws Exception { Enumeration < Object > enm ; Vector < Vector < ? > > deserialized ; Object key ; deserialized = ( Vector < Vector < ? > > ) super . read Post Process ( o ) ; rebuild Bean Connections ( deserialized , REGULAR CONNECTION ) ; enm = m Bean Connection Relation . keys ( ) ; while ( enm . has More Elements ( ) ) { key = enm . next Element ( ) ; if ( ! ( key instanceof Meta Bean ) ) { continue ; } rebuild Bean Connections ( deserialized , key ) ; } if ( get Data Type ( ) == DATATYPE USERCOMPONENTS ) { remove User Tool Bar Beans ( deserialized ) ; } return deserialized ; }
public static boolean can See ( I Game game , Entity ae , Targetable target ) { return can See ( game , ae , target , BOOL , null , null ) ; }
@ Override void to XML ( String Builder xml , int level ) { indent ( xml , level ) ; xml . append ( STRING ) ; for ( int i = NUM ; i < bytes . length ; i ++ ) { byte b = bytes [ i ] ; if ( b < NUM ) xml . append ( STRING ) ; xml . append ( Integer . to Hex String ( b ) ) ; } xml . append ( STRING ) ; }
public final int read Line ( char [ ] buf , int length , boolean is Chop ) throws IO Exception { byte [ ] read Buffer = read Buffer ; int offset = NUM ; while ( BOOL ) { int read Offset = read Offset ; int sublen = Math . min ( length , read Length - read Offset ) ; for ( ; sublen > NUM ; sublen -- ) { int ch = read Buffer [ read Offset ++ ] & NUM ; if ( ch != STRING ) { } else if ( is Chop ) { read Offset = read Offset ; if ( offset > NUM && buf [ offset - NUM ] == STRING ) return offset - NUM ; else return offset ; } else { buf [ offset ++ ] = ( char ) ch ; read Offset = read Offset ; return offset + NUM ; } buf [ offset ++ ] = ( char ) ch ; } read Offset = read Offset ; if ( read Offset <= read Length ) { if ( ! read Buffer ( ) ) { return offset ; } } if ( length <= offset ) return length + NUM ; } }
public static void goto Offset ( final C Debug Perspective Model model , final I Address offset , final boolean focus Memory Window ) { model . set Active Memory Address ( offset , focus Memory Window ) ; }
public List < Abstract Condition > to Conditions List ( ) { List < Abstract Condition > list = new Array List < > ( ) ; for ( Node < Abstract Condition > node : to List ( ) ) { list . add ( node . get Data ( ) ) ; } return list ; }
protected void init Batch Buffer ( ) { try { if ( ! is Incremental ( ) ) { m Batch Buffer = m Loader . get Data Set ( ) ; } else { m Batch Buffer = null ; } } catch ( Exception e ) { e . print Stack Trace ( ) ; } }
public Bigdata Sail Repository Connection cxn ( ) { return tl Tx . get ( ) ; }
public void process Connection ( Data Input Stream dis , Data Output Stream dos Param ) throws IO Exception , Exception { GZIP Output Stream gzip = new GZIP Output Stream ( new Buffered Output Stream ( dos Param ) ) ; Data Output Stream dos = new Data Output Stream ( gzip ) ; byte response Status = Response Status . STATUS ERROR ; try { Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; String name = dis . read UTF ( ) ; String pw = dis . read UTF ( ) ; String serializer = dis . read UTF ( ) ; @ Suppress Warnings ( STRING ) String locale = dis . read UTF ( ) ; byte action = dis . read Byte ( ) ; Context . open Session ( ) ; try { Context . authenticate ( name , pw ) ; } catch ( Context Authentication Exception ex ) { response Status = Response Status . STATUS ACCESS DENIED ; } if ( response Status != Response Status . STATUS ACCESS DENIED ) { Data Output Stream dos Temp = new Data Output Stream ( baos ) ; if ( action == ACTION DOWNLOAD PATIENTS ) download Patients ( String . value Of ( dis . read Int ( ) ) , dos Temp , serializer , BOOL ) ; else if ( action == ACTION DOWNLOAD SS PATIENTS ) download Patients ( String . value Of ( dis . read Int ( ) ) , dos Temp , serializer , BOOL ) ; else if ( action == ACTION DOWNLOAD COHORTS ) Patient Download Manager . download Cohorts ( dos Temp , serializer ) ; else if ( action == ACTION DOWNLOAD SAVED SEARCHES ) Patient Download Manager . download Saves Searches ( dos Temp , serializer ) ; else if ( action == ACTION DOWNLOAD FORMS ) Xform Download Manager . download Xforms ( dos Temp , serializer ) ; else if ( action == ACTION UPLOAD FORMS ) submit Xforms ( dis , dos Temp , serializer ) ; else if ( action == ACTION DOWNLOAD USERS ) User Download Manager . download Users ( dos Temp , serializer ) ; else if ( action == ACTION DOWNLOAD USERS AND FORMS ) download Users And Forms ( dos Temp , serializer ) ; else if ( action == ACTION DOWNLOAD FILTERED PATIENTS ) download Patients ( dis . read UTF ( ) , dis . read UTF ( ) , dos Temp , serializer ) ; response Status = Response Status . STATUS SUCCESS ; } dos . write Byte ( response Status ) ; if ( response Status == Response Status . STATUS SUCCESS ) dos . write ( baos . to Byte Array ( ) ) ; dos . close ( ) ; gzip . finish ( ) ; } catch ( Exception ex ) { log . error ( ex . get Message ( ) , ex ) ; try { dos . write Byte ( response Status ) ; dos . flush ( ) ; gzip . finish ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } } finally { Context . close Session ( ) ; } }
