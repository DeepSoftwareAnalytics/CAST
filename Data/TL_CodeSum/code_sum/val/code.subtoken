public int hash Code ( ) { return value . hash Code ( ) ; }
public void on Start ( ) { }
@ Override protected void property Change ( Property Change Event evt ) { if ( Sea Glass Look And Feel . should Update Style ( evt ) ) { update Style ( ( J Text Component ) evt . get Source ( ) ) ; } super . property Change ( evt ) ; }
protected void write Qualified Name ( String ns Alias , String name ) throws IO Exception { if ( ns Alias != null && ns Alias . length ( ) > NUM ) { writer . write ( ns Alias ) ; writer . write ( STRING ) ; } writer . write ( name ) ; }
public Text Editor delete All ( String pattern ) { return replace All ( pattern , STRING ) ; }
public synchronized Gcm Helper add Registration Callback ( @ Non Null Context context , @ Non Null Gcm Registration Listener registration Listener , boolean sticky ) { if ( null == registration Callbacks ) { registration Callbacks = new Concurrent Linked Queue < > ( ) ; } registration Callbacks . add ( registration Listener ) ; if ( sticky && ! Text Utils . is Empty ( this . push Token ) ) { registration Listener . on Token Available ( context , push Token , BOOL ) ; } return this ; }
@ Override public void accept Training Set ( Training Set Event e ) { Instances training Set = e . get Training Set ( ) ; Data Set Event dse = new Data Set Event ( this , training Set ) ; accept Data Set ( dse ) ; }
private boolean is Agent Empty ( Agent agent ) { if ( agent != null ) { String first = agent . get First Name ( ) ; String last = agent . get Last Name ( ) ; String email = agent . get Email ( ) ; String home = agent . get Homepage ( ) ; String org = agent . get Organisation ( ) ; String phone = agent . get Phone ( ) ; String position = agent . get Position ( ) ; String city = null ; String street = null ; String country = null ; String code = null ; String province = null ; Address address = agent . get Address ( ) ; if ( address != null ) { city = address . get City ( ) ; street = address . get Address ( ) ; country = address . get Country ( ) ; code = address . get Postal Code ( ) ; province = address . get Province ( ) ; } String directory = null ; String identifier = null ; List < User Id > user Ids = agent . get User Ids ( ) ; if ( ! user Ids . is Empty ( ) ) { User Id user Id = user Ids . get ( NUM ) ; directory = user Id . get Directory ( ) ; identifier = user Id . get Identifier ( ) ; } return ( Strings . is Null Or Empty ( city ) && Strings . is Null Or Empty ( street ) && Strings . is Null Or Empty ( country ) && Strings . is Null Or Empty ( code ) && Strings . is Null Or Empty ( province ) && Strings . is Null Or Empty ( first ) && Strings . is Null Or Empty ( last ) && Strings . is Null Or Empty ( email ) && Strings . is Null Or Empty ( home ) && Strings . is Null Or Empty ( org ) && Strings . is Null Or Empty ( phone ) && Strings . is Null Or Empty ( position ) && Strings . is Null Or Empty ( directory ) && Strings . is Null Or Empty ( identifier ) ) ; } return BOOL ; }
public static byte [ ] calendar To Raw Bytes ( Calendar timestamp , boolean honor Device Time Offset ) { if ( honor Device Time Offset ) { int offset In Hours = Mi Band Coordinator . get Device Time Offset Hours ( ) ; if ( offset In Hours != NUM ) { timestamp . add ( Calendar . HOUR OF DAY , offset In Hours ) ; } } byte [ ] year = from Uint 16 ( timestamp . get ( Calendar . YEAR ) ) ; return new byte [ ] { year [ NUM ] , year [ NUM ] , from Uint 8 ( timestamp . get ( Calendar . MONTH ) + NUM ) , from Uint 8 ( timestamp . get ( Calendar . DATE ) ) , from Uint 8 ( timestamp . get ( Calendar . HOUR OF DAY ) ) , from Uint 8 ( timestamp . get ( Calendar . MINUTE ) ) , from Uint 8 ( timestamp . get ( Calendar . SECOND ) ) , day Of Week To Raw Bytes ( timestamp ) , NUM } ; }
private static void decode Base 256 Segment ( Bit Source bits , String Builder result , Collection < byte [ ] > byte Segments ) throws Format Exception { int codeword Position = NUM + bits . get Byte Offset ( ) ; int d1 = unrandomize 255 State ( bits . read Bits ( NUM ) , codeword Position ++ ) ; int count ; if ( d1 == NUM ) { count = bits . available ( ) / NUM ; } else if ( d1 < NUM ) { count = d1 ; } else { count = NUM * ( d1 - NUM ) + unrandomize 255 State ( bits . read Bits ( NUM ) , codeword Position ++ ) ; } if ( count < NUM ) { throw Format Exception . get Format Instance ( ) ; } byte [ ] bytes = new byte [ count ] ; for ( int i = NUM ; i < count ; i ++ ) { if ( bits . available ( ) < NUM ) { throw Format Exception . get Format Instance ( ) ; } bytes [ i ] = ( byte ) unrandomize 255 State ( bits . read Bits ( NUM ) , codeword Position ++ ) ; } byte Segments . add ( bytes ) ; try { result . append ( new String ( bytes , STRING ) ) ; } catch ( Unsupported Encoding Exception uee ) { throw new Illegal State Exception ( STRING + uee ) ; } }
protected void init BP Order Details ( int C B Partner ID , boolean for Invoice ) { log . config ( STRING + C B Partner ID ) ; Key Name Pair pp = new Key Name Pair ( NUM , STRING ) ; order Field . remove Action Listener ( this ) ; order Field . remove All Items ( ) ; order Field . add Item ( pp ) ; Array List < Key Name Pair > list = load Order Data ( C B Partner ID , for Invoice , same Warehouse Cb . is Selected ( ) ) ; for ( Key Name Pair knp : list ) order Field . add Item ( knp ) ; order Field . set Selected Index ( NUM ) ; order Field . add Action Listener ( this ) ; init BP Details ( C B Partner ID ) ; }
public Modpack Initialization Panel ( Wizard Controller controller , Map wizard Data , Vector < String > versions , String sel Version ) { init Components ( ) ; this . controller = controller ; this . wizard Data = wizard Data ; wizard Data . put ( KEY GAME VERSION , versions ) ; wizard Data . put ( STRING , sel Version ) ; wizard Data . put ( KEY INCLUDING LAUNCHER , BOOL ) ; configure Combo Contents ( ) ; check Problem ( ) ; }
public synchronized void remove ( int index ) { super . remove ( index ) ; double removed Value = m Value . remove ( index ) ; if ( removed Value == m Min Value || removed Value == m Max Value ) { init Range ( ) ; } }
private boolean coord Is Calendar Cell ( float y ) { return y > cell Height ; }
protected void sprint ( double double Field ) { sprint ( String . value Of ( double Field ) ) ; }
private int attribute Map ( String name ) { Integer num = map . get ( name ) ; if ( num == null ) { return NUM ; } return num . int Value ( ) ; }
private void group Player Standing CSV ( ) { for ( Player QB p : team Q Bs ) { if ( p . year == NUM ) team R Ss . add ( p ) ; else if ( p . year == NUM ) team F Rs . add ( p ) ; else if ( p . year == NUM ) team S Os . add ( p ) ; else if ( p . year == NUM ) team J Rs . add ( p ) ; else if ( p . year == NUM ) team S Rs . add ( p ) ; } for ( Player RB p : team R Bs ) { if ( p . year == NUM ) team R Ss . add ( p ) ; else if ( p . year == NUM ) team F Rs . add ( p ) ; else if ( p . year == NUM ) team S Os . add ( p ) ; else if ( p . year == NUM ) team J Rs . add ( p ) ; else if ( p . year == NUM ) team S Rs . add ( p ) ; } for ( Player WR p : team W Rs ) { if ( p . year == NUM ) team R Ss . add ( p ) ; else if ( p . year == NUM ) team F Rs . add ( p ) ; else if ( p . year == NUM ) team S Os . add ( p ) ; else if ( p . year == NUM ) team J Rs . add ( p ) ; else if ( p . year == NUM ) team S Rs . add ( p ) ; } for ( Player K p : team Ks ) { if ( p . year == NUM ) team R Ss . add ( p ) ; else if ( p . year == NUM ) team F Rs . add ( p ) ; else if ( p . year == NUM ) team S Os . add ( p ) ; else if ( p . year == NUM ) team J Rs . add ( p ) ; else if ( p . year == NUM ) team S Rs . add ( p ) ; } for ( Player OL p : team O Ls ) { if ( p . year == NUM ) team R Ss . add ( p ) ; else if ( p . year == NUM ) team F Rs . add ( p ) ; else if ( p . year == NUM ) team S Os . add ( p ) ; else if ( p . year == NUM ) team J Rs . add ( p ) ; else if ( p . year == NUM ) team S Rs . add ( p ) ; } for ( Player S p : team Ss ) { if ( p . year == NUM ) team R Ss . add ( p ) ; else if ( p . year == NUM ) team F Rs . add ( p ) ; else if ( p . year == NUM ) team S Os . add ( p ) ; else if ( p . year == NUM ) team J Rs . add ( p ) ; else if ( p . year == NUM ) team S Rs . add ( p ) ; } for ( Player CB p : team C Bs ) { if ( p . year == NUM ) team R Ss . add ( p ) ; else if ( p . year == NUM ) team F Rs . add ( p ) ; else if ( p . year == NUM ) team S Os . add ( p ) ; else if ( p . year == NUM ) team J Rs . add ( p ) ; else if ( p . year == NUM ) team S Rs . add ( p ) ; } for ( Player F 7 p : team F 7 s ) { if ( p . year == NUM ) team R Ss . add ( p ) ; else if ( p . year == NUM ) team F Rs . add ( p ) ; else if ( p . year == NUM ) team S Os . add ( p ) ; else if ( p . year == NUM ) team J Rs . add ( p ) ; else if ( p . year == NUM ) team S Rs . add ( p ) ; } }
public String list ( ) throws IO Exception , Tomcat Manager Exception { return invoke ( STRING , null , null ) ; }
public Attribute Filler ( Attributes Impl attributes , PO po To Auto Fill ) { attributes . clear ( ) ; atts = attributes ; po = po To Auto Fill ; }
public static final void to Byte Array ( Byte Array Output Stream output , String str ) { if ( str == null ) { return ; } output . write ( NUM ) ; int max = str . length ( ) ; for ( int i = NUM ; i < max ; i ++ ) { int b = str . char At ( i ) ; if ( ( b >= NUM ) && ( b <= NUM ) ) { switch ( b ) { case NUM : case NUM : output . write ( NUM ) ; break ; } output . write ( b ) ; } else { output . write ( NUM ) ; switch ( b ) { case NUM : output . write ( NUM ) ; break ; case NUM : output . write ( NUM ) ; break ; case NUM : output . write ( NUM ) ; break ; case NUM : output . write ( NUM ) ; break ; case NUM : output . write ( NUM ) ; break ; default : output . write ( NUM ) ; int b3 = b > > NUM ; int b4 = b & NUM ; if ( b4 < NUM ) b4 += NUM ; else b4 += NUM ; int b2 = b3 > > NUM ; b3 &= NUM ; if ( b3 < NUM ) b3 += NUM ; else b3 += NUM ; int b1 = b2 > > NUM ; b2 &= NUM ; if ( b2 < NUM ) b2 += NUM ; else b2 += NUM ; if ( b1 < NUM ) b1 += NUM ; else b1 += NUM ; output . write ( b1 ) ; output . write ( b2 ) ; output . write ( b3 ) ; output . write ( b4 ) ; break ; } } } output . write ( NUM ) ; }
@ Request Mapping ( value = { STRING , STRING } , method = Request Method . PUT ) @ Response Body public Rest Wrapper insert ( @ Model Attribute ( STRING ) @ Valid File file , Binding Result binding Result , Principal principal ) { Rest Wrapper rest Wrapper = null ; if ( binding Result . has Errors ( ) ) { Binding Result Error binding Result Error = new Binding Result Error ( ) ; return binding Result Error . error Message ( binding Result ) ; } try { file . set Creation TS ( Date Converter . string To Date ( file . get Table Creation TS ( ) ) ) ; file DAO . insert ( file ) ; rest Wrapper = new Rest Wrapper ( file , Rest Wrapper . OK ) ; LOGGER . info ( STRING + file . get Batch Id ( ) + STRING + principal . get Name ( ) + file ) ; } catch ( Metadata Exception e ) { LOGGER . error ( e ) ; rest Wrapper = new Rest Wrapper ( e . get Message ( ) , Rest Wrapper . ERROR ) ; } return rest Wrapper ; }
private void enable Updates ( ) { if ( lmgr != null ) { try { lmgr . add Gps Status Listener ( this ) ; lmgr . request Location Updates ( Location Manager . GPS PROVIDER , gps Logging Interval , NUM , this ) ; } catch ( Security Exception e ) { Log . e ( TAG , STRING ) ; } } }
private void add Integer ( ) { int old Pos = pos - NUM ; String literal = scan Integer ( ) ; final String substring ; final int radix ; if ( literal . starts With ( STRING ) || literal . starts With ( STRING ) ) { radix = NUM ; substring = literal . substring ( NUM ) ; } else if ( literal . starts With ( STRING ) && literal . length ( ) > NUM ) { radix = NUM ; substring = literal . substring ( NUM ) ; } else { radix = NUM ; substring = literal ; } int value = NUM ; try { value = Integer . parse Int ( substring , radix ) ; } catch ( Number Format Exception e ) { error ( STRING + radix + STRING + literal ) ; } add Token ( Token Kind . INT , old Pos , pos , value ) ; }
public void remove Mouse Listener ( Global Mouse Listener listener ) { listeners . remove ( listener ) ; }
public Object Name create Distribution Locator ( String host , int port , String working Directory , String product Directory , String remote Command ) throws Malformed Object Name Exception { try { Distribution Locator Jmx Impl locator = ( Distribution Locator Jmx Impl ) add Distribution Locator ( ) ; Distribution Locator Config config = locator . get Config ( ) ; config . set Host ( host ) ; config . set Port ( port ) ; config . set Working Directory ( working Directory ) ; config . set Product Directory ( product Directory ) ; config . set Remote Command ( remote Command ) ; return new Object Name ( locator . get M Bean Name ( ) ) ; } catch ( Runtime Exception e ) { logger . warn ( e . get Message ( ) , e ) ; throw e ; } catch ( Virtual Machine Error err ) { System Failure . initiate Failure ( err ) ; throw err ; } catch ( Error e ) { System Failure . check Failure ( ) ; logger . error ( e . get Message ( ) , e ) ; throw e ; } }
void apply Center Panel ( Grass Marlin ui ) { if ( tree View Component != null ) { center Panel Component . add ( tree View Component , Split Pane . Position . CENTER ) ; } center Panel Component . add ( graph Component , Split Pane . Position . RIGHT ) ; center Panel Component . add ( log Component , Split Pane . Position . LEFT BOTTOM ) ; Border b = Border Factory . create Matte Border ( NUM , NUM , NUM , NUM , Color . GRAY ) ; Border b2 = Border Factory . create Matte Border ( NUM , NUM , NUM , NUM , Color . GRAY ) ; tree View Component . set Border ( b2 ) ; graph Component . set Border ( b ) ; log Component . set Border ( b2 ) ; center Panel Component . set Initial Size ( x , y ) ; Dimension d = new Dimension ( NUM , NUM ) ; ui . add ( new Filler ( d , d , d ) , Border Layout . WEST ) ; ui . add ( new Filler ( d , d , d ) , Border Layout . EAST ) ; ui . add ( center Panel Component , Border Layout . CENTER ) ; }
private boolean is Abstract ( String source ) { int nonterminal Count = NUM ; for ( String t : source . split ( STRING ) ) { if ( ! t . matches ( NT REGEX ) ) return BOOL ; nonterminal Count ++ ; } return nonterminal Count != NUM ; }
public static String UR Ifor Portable Path ( String path ) { if ( path . starts With ( File Util . PREFERENCES ) ) { return path . replace First ( File Util . PREFERENCES , STRING ) ; } else if ( path . starts With ( File Util . PROGRAM ) ) { return path . replace First ( File Util . PROGRAM , STRING ) ; } else { return null ; } }
public int hash Code ( ) { return Float . float To Int Bits ( value ) ; }
public static void log ( Throwable error , String message , Object ... args ) { if ( logging Enabled ) { Log . d ( TAG , args . length == NUM ? message : String . format ( message , args ) , error ) ; } }
public void add Extension Namespace ( String uri , Extension Handler ext NS ) { m extension Function Namespaces . put ( uri , ext NS ) ; }
private void generate Type Parameter Infos ( Binary Member parent , char [ ] signature , Hash Map new Elements , Array List type Parameter Handles ) { if ( signature == null ) return ; char [ ] [ ] type Parameter Signatures = Signature . get Type Parameters ( signature ) ; for ( int i = NUM , type Parameter Count = type Parameter Signatures . length ; i < type Parameter Count ; i ++ ) { char [ ] type Parameter Signature = type Parameter Signatures [ i ] ; char [ ] type Parameter Name = Signature . get Type Variable ( type Parameter Signature ) ; Char Operation . replace ( type Parameter Signature , STRING , STRING ) ; char [ ] [ ] type Parameter Bound Signatures = Signature . get Type Parameter Bounds ( type Parameter Signature ) ; int bound Length = type Parameter Bound Signatures . length ; char [ ] [ ] type Parameter Bounds = new char [ bound Length ] [ ] ; for ( int j = NUM ; j < bound Length ; j ++ ) { type Parameter Bounds [ j ] = Signature . to Char Array ( type Parameter Bound Signatures [ j ] ) ; } Type Parameter type Parameter = new Type Parameter ( parent , parent . manager , new String ( type Parameter Name ) ) ; Type Parameter Element Info info = new Type Parameter Element Info ( ) ; info . bounds = type Parameter Bounds ; info . bounds Signatures = type Parameter Bound Signatures ; type Parameter Handles . add ( type Parameter ) ; while ( new Elements . contains Key ( type Parameter ) ) type Parameter . occurrence Count ++ ; new Elements . put ( type Parameter , info ) ; } }
public final void test Next Bytesbyte Array 02 ( ) { byte [ ] my Bytes ; byte [ ] my Bytes 1 ; byte [ ] my Bytes 2 ; for ( int i = NUM ; i < LENGTH ; i += INCR ) { my Bytes = new byte [ i ] ; for ( int j = NUM ; j < i ; j ++ ) { my Bytes [ j ] = ( byte ) ( j & NUM ) ; } sr . set Seed ( my Bytes ) ; sr 2 . set Seed ( my Bytes ) ; for ( int k = NUM ; k < LENGTH ; k += INCR ) { my Bytes 1 = new byte [ k ] ; my Bytes 2 = new byte [ k ] ; sr . next Bytes ( my Bytes 1 ) ; sr 2 . next Bytes ( my Bytes 2 ) ; for ( int l = NUM ; l < k ; l ++ ) { assert False ( STRING + l + STRING + k + STRING + i + STRING + my Bytes 1 [ l ] + STRING + my Bytes 2 [ l ] , my Bytes 1 [ l ] != my Bytes 2 [ l ] ) ; } } } for ( int n = NUM ; n < LENGTH ; n += INCR ) { int n1 = NUM ; int n2 = NUM ; int n3 = NUM ; byte [ ] [ ] bytes 1 = new byte [ NUM ] [ n1 ] ; byte [ ] [ ] bytes 2 = new byte [ NUM ] [ n2 ] ; for ( int k = NUM ; k < bytes 1 . length ; k ++ ) { sr . next Bytes ( bytes 1 [ k ] ) ; } for ( int k = NUM ; k < bytes 2 . length ; k ++ ) { sr 2 . next Bytes ( bytes 2 [ k ] ) ; } for ( int k = NUM ; k < n3 ; k ++ ) { int i1 = k / n1 ; int i2 = k % n1 ; int i3 = k / n2 ; int i4 = k % n2 ; assert True ( STRING + i1 + STRING + i2 + STRING + i3 + STRING + i4 , bytes 1 [ i1 ] [ i2 ] == bytes 2 [ i3 ] [ i4 ] ) ; } } }
private void signal Not Empty ( ) { final Reentrant Lock take Lock = this . take Lock ; take Lock . lock ( ) ; try { not Empty . signal ( ) ; } finally { take Lock . unlock ( ) ; } }
public Routing Info ( Object o ) { this . text = o . to String ( ) ; }
private List < View > add View ( View view , List < View > cache ) { if ( cache == null ) { cache = new Linked List < View > ( ) ; } cache . add ( view ) ; return cache ; }
public static Cert Chain Key Pair generate Signed ( String fqdn , X509 Certificate issuer Certificate , Private Key issuer Private Key ) { try { return generate Certificate And Sign ( fqdn , issuer Certificate , issuer Private Key , get Server Extensions ( issuer Certificate ) ) ; } catch ( Certificate Exception | Operator Creation Exception | No Such Algorithm Exception | IO Exception e ) { throw new Runtime Exception ( String . format ( STRING , e . get Message ( ) ) , e ) ; } }
private void start Animation ( ) { Value Animator animator = Value Animator . of Float ( NUM ) ; Array List < Name Values Holder > name Value List = ( Array List < Name Values Holder > ) m Pending Animations . clone ( ) ; m Pending Animations . clear ( ) ; int property Mask = NUM ; int property Count = name Value List . size ( ) ; for ( int i = NUM ; i < property Count ; ++ i ) { Name Values Holder name Values Holder = name Value List . get ( i ) ; property Mask |= name Values Holder . m Name Constant ; } m Animator Map . put ( animator , new Property Bundle ( property Mask , name Value List ) ) ; animator . add Update Listener ( m Animator Event Listener ) ; animator . add Listener ( m Animator Event Listener ) ; if ( m Start Delay Set ) { animator . set Start Delay ( m Start Delay ) ; } if ( m Duration Set ) { animator . set Duration ( m Duration ) ; } if ( m Interpolator Set ) { animator . set Interpolator ( m Interpolator ) ; } animator . start ( ) ; }
public void add Request ( Request request ) { request Set . add ( request ) ; }
public static double logpmf ( double x , int n , double p ) { if ( x < NUM || x > n ) { return Double . NEGATIVE INFINITY ; } if ( p <= NUM ) { return x == NUM ? NUM : Double . NEGATIVE INFINITY ; } if ( p >= NUM ) { return x == n ? NUM : Double . NEGATIVE INFINITY ; } final double q = NUM - p ; if ( x == NUM ) { if ( p < NUM ) { return - deviance Term ( n , n * q ) - n * p ; } else { return n * Math . log ( q ) ; } } if ( x == n ) { if ( p > NUM ) { return - deviance Term ( n , n * p ) - n * q ; } else { return n * Math . log ( p ) ; } } final double lc = stirling Error ( n ) - stirling Error ( x ) - stirling Error ( n - x ) - deviance Term ( x , n * p ) - deviance Term ( n - x , n * q ) ; final double f = ( Math Util . TWOPI * x * ( n - x ) ) / n ; return lc - NUM * Math . log ( f ) ; }
private void byte 2 hex ( byte b , String Buffer buf ) { char [ ] hex Chars = { STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING } ; int high = ( ( b & NUM ) > > NUM ) ; int low = ( b & NUM ) ; buf . append ( hex Chars [ high ] ) ; buf . append ( hex Chars [ low ] ) ; }
public static List < Geo Time Serie > timesplit ( Geo Time Serie gts , long quietperiod , int minvalues , String labelname ) { List < Geo Time Serie > series = new Array List < Geo Time Serie > ( ) ; if ( NUM == gts . values || gts . has Label ( labelname ) ) { series . add ( gts . clone ( ) ) ; return series ; } sort ( gts , BOOL ) ; long lasttick = gts . ticks [ NUM ] ; int idx = NUM ; int gtsid = NUM ; Geo Time Serie serie = new Geo Time Serie ( gts . lastbucket , gts . bucketcount , gts . bucketspan , NUM ) ; serie . set Name ( gts . get Name ( ) ) ; Map < String , String > labels = new Hash Map < String , String > ( ) ; labels . put All ( gts . get Labels ( ) ) ; labels . put ( labelname , Integer . to String ( gtsid ) ) ; serie . set Labels ( labels ) ; while ( idx < gts . values ) { if ( gts . ticks [ idx ] - lasttick >= quietperiod ) { if ( serie . values > NUM && serie . values >= minvalues ) { series . add ( serie ) ; } serie = new Geo Time Serie ( gts . lastbucket , gts . bucketcount , gts . bucketspan , NUM ) ; serie . set Name ( gts . get Name ( ) ) ; labels = new Hash Map < String , String > ( ) ; labels . put All ( gts . get Labels ( ) ) ; gtsid ++ ; labels . put ( labelname , Integer . to String ( gtsid ) ) ; serie . set Labels ( labels ) ; } Object value = GTS Helper . value At Index ( gts , idx ) ; GTS Helper . set Value ( serie , gts . ticks [ idx ] , null != gts . locations ? gts . locations [ idx ] : Geo Time Serie . NO LOCATION , null != gts . elevations ? gts . elevations [ idx ] : Geo Time Serie . NO ELEVATION , value , BOOL ) ; lasttick = gts . ticks [ idx ] ; idx ++ ; } if ( serie . values > NUM && serie . values >= minvalues ) { series . add ( serie ) ; } return series ; }
protected void check Signature ( byte [ ] buf ) { if ( ! Arrays . equals ( buf , Png Helper Internal . get Png Id Signature ( ) ) ) throw new Pngj Input Exception ( STRING ) ; }
private void two Way Merge Internal ( final Reservoir Longs Sketch sketch In , final boolean is Modifiable ) { if ( sketch In . get N ( ) <= sketch In . get K ( ) ) { two Way Merge Internal Standard ( sketch In ) ; } else if ( gadget . get N ( ) < gadget . get K ( ) ) { final Reservoir Longs Sketch tmp Sketch = gadget ; gadget = ( is Modifiable ? sketch In : sketch In . copy ( ) ) ; two Way Merge Internal Standard ( tmp Sketch ) ; } else if ( sketch In . get Implicit Sample Weight ( ) < gadget . get N ( ) / ( ( double ) ( gadget . get K ( ) - NUM ) ) ) { two Way Merge Internal Weighted ( sketch In ) ; } else { final Reservoir Longs Sketch tmp Sketch = gadget ; gadget = ( is Modifiable ? sketch In : sketch In . copy ( ) ) ; two Way Merge Internal Weighted ( tmp Sketch ) ; } }
final public void print ( Object v ) { Writer out = this . out ; if ( out == null ) return ; try { if ( v == null ) out . write ( null Chars , NUM , null Chars . length ) ; else { String s = v . to String ( ) ; out . write ( s , NUM , s . length ( ) ) ; } } catch ( IO Exception e ) { log . log ( Level . FINE , e . to String ( ) , e ) ; } }
public void subscribe To ( final K key , final Subscriber < V > subscriber , final Executor subscribe On ) { Completable Future . run Async ( null , subscribe On ) ; }
public static boolean copy Stream ( Input Stream is , Output Stream os , Copy Listener listener , int buffer Size ) throws IO Exception { int current = NUM ; int total = is . available ( ) ; if ( total <= NUM ) { total = DEFAULT IMAGE TOTAL SIZE ; } final byte [ ] bytes = new byte [ buffer Size ] ; int count ; if ( should Stop Loading ( listener , current , total ) ) return BOOL ; while ( ( count = is . read ( bytes , NUM , buffer Size ) ) != - NUM ) { os . write ( bytes , NUM , count ) ; current += count ; if ( should Stop Loading ( listener , current , total ) ) return BOOL ; } os . flush ( ) ; return BOOL ; }
private void refresh Buffer ( ) throws IO Exception { if ( output == null ) { throw new Out Of Space Exception ( ) ; } output . write ( buffer , NUM , position ) ; position = NUM ; }
public String damage Bay Door ( ) { String bay Type = STRING ; Vector < Bay > potential ; potential = new Vector < Bay > ( ) ; Enumeration < Transporter > iter = transports . elements ( ) ; while ( iter . has More Elements ( ) ) { Transporter next = iter . next Element ( ) ; if ( next instanceof Bay ) { Bay next Bay = ( Bay ) next ; if ( next Bay . get Doors ( ) > NUM ) { potential . add ( next Bay ) ; } } } if ( potential . size ( ) > NUM ) { Bay chosen Bay = potential . element At ( Compute . random Int ( potential . size ( ) ) ) ; chosen Bay . destroy Door ( ) ; chosen Bay . reset Doors ( ) ; chosen Bay . set Doors ( chosen Bay . get Doors ( ) - NUM ) ; bay Type = chosen Bay . get Type ( ) ; } return bay Type ; }
public void update Enabled State ( ) { boolean b = ( get Simulation Thread ( ) == null ) ; boolean prep = b && controller != null && controller . is Prepared ( ) ; clear Button . set Enabled ( b ) ; prepare Button . set Enabled ( b ) ; run Button . set Enabled ( prep ) ; if ( b ) pause Button . set Selected ( BOOL ) ; pause Button . set Enabled ( ! b ) ; step Button . set Enabled ( prep ) ; cancel Button . set Enabled ( ! b ) ; for ( J Combo Box < Object > combo : selectors . combos ) combo . set Enabled ( b ) ; }
private void prepare Volume Data ( ) throws Exception { prepare V Plex Volume Data ( ) ; prepare RP Volume Data ( ) ; }
private static int determine Icon Id By Mime Type List ( List < String > mimetypes ) { if ( mimetypes == null || mimetypes . size ( ) < NUM ) { return R . drawable . file ; } else { for ( String mimetype : mimetypes ) { Integer icon Id = MIMETYPE TO ICON MAPPING . get ( mimetype ) ; if ( icon Id != null ) { return icon Id ; } } for ( String mimetype : mimetypes ) { String main Mimetype Part = mimetype . split ( STRING ) [ NUM ] ; Integer icon Id = MAINMIMETYPE TO ICON MAPPING . get ( main Mimetype Part ) ; if ( icon Id != null ) { return icon Id ; } } } return R . drawable . file ; }
public void attribute As Class ( ) { Data Sorted Table Model model ; if ( m Current Col == - NUM ) { return ; } model = ( Data Sorted Table Model ) m Table Data . get Model ( ) ; if ( model . get Attribute At ( m Current Col ) == null ) { return ; } set Cursor ( Cursor . get Predefined Cursor ( Cursor . WAIT CURSOR ) ) ; model . attribute As Class At ( m Current Col ) ; set Cursor ( Cursor . get Predefined Cursor ( Cursor . DEFAULT CURSOR ) ) ; }
public void add Listener ( Refresh Listener listener ) { if ( listener == null ) { throw new Null Pointer Exception ( STRING ) ; } refresh Listeners . add ( listener ) ; }
public final void do Export ( final String track Name , final File target , int verbosity ) throws IO Exception { Log . i ( TAG , STRING + target . get Absolute Path ( ) ) ; m Db Helper = new Database Helper ( m Context . get Application Context ( ) ) ; final Buffered Writer bw = new Buffered Writer ( new File Writer ( target ) ) ; bw . write ( XML HEADER ) ; bw . write ( TAG GPX ) ; if ( verbosity == VERBOSITY TRACK AND WAYPOINTS || verbosity == VERBOSITY WAYPOINTS ONLY || verbosity == VERBOSITY ALL ) { write Waypoints ( bw ) ; } if ( verbosity == VERBOSITY TRACK AND WAYPOINTS || verbosity == VERBOSITY ALL ) { write Trackpoints ( track Name , bw ) ; } bw . flush ( ) ; if ( verbosity == VERBOSITY ALL ) { write Wifis ( bw ) ; bw . flush ( ) ; write Cells ( bw ) ; bw . flush ( ) ; } bw . write ( TAG GPX CLOSE ) ; bw . close ( ) ; m Db Helper . close ( ) ; Log . i ( TAG , STRING ) ; }
public List < V > values In Selection ( Rich Edit Text editor , int span Type ) { List < V > result = new Array List < V > ( ) ; Selection expanded Selection = get Expanded Selection ( editor , span Type ) ; if ( expanded Selection != null ) { for ( Span < V > span : get Spans ( editor . get Text ( ) , expanded Selection ) ) { result . add ( span . get Value ( ) ) ; } } return result ; }
private boolean is GTE Delta ( double value ) { return Math . abs ( value ) - Math . abs ( m Delta ) > - NUM ; }
public static String row To String ( JSON Array ja ) { String Builder sb = new String Builder ( ) ; for ( int i = NUM ; i < ja . length ( ) ; i += NUM ) { if ( i > NUM ) { sb . append ( STRING ) ; } Object object = ja . opt ( i ) ; if ( object != null ) { String string = object . to String ( ) ; if ( string . length ( ) > NUM && ( string . index Of ( STRING ) >= NUM || string . index Of ( STRING ) >= NUM || string . index Of ( STRING ) >= NUM || string . index Of ( NUM ) >= NUM || string . char At ( NUM ) == STRING ) ) { sb . append ( STRING ) ; int length = string . length ( ) ; for ( int j = NUM ; j < length ; j += NUM ) { char c = string . char At ( j ) ; if ( c >= STRING && c != STRING ) { sb . append ( c ) ; } } sb . append ( STRING ) ; } else { sb . append ( string ) ; } } } sb . append ( STRING ) ; return sb . to String ( ) ; }
private void maybe Sample Sync Params ( ) { long playback Position Us = audio Track Util . get Playback Head Position Us ( ) ; if ( playback Position Us == NUM ) { return ; } if ( log . allow Verbose ( ) ) { log . v ( STRING + playback Position Us ) ; } long system Clock Us = System . nano Time ( ) / NUM ; if ( system Clock Us - last Playhead Sample Time Us >= MIN PLAYHEAD OFFSET SAMPLE INTERVAL US ) { playhead Offsets [ next Playhead Offset Index ] = playback Position Us - system Clock Us ; next Playhead Offset Index = ( next Playhead Offset Index + NUM ) % MAX PLAYHEAD OFFSET COUNT ; if ( playhead Offset Count < MAX PLAYHEAD OFFSET COUNT ) { playhead Offset Count ++ ; } last Playhead Sample Time Us = system Clock Us ; smoothed Playhead Offset Us = NUM ; for ( int i = NUM ; i < playhead Offset Count ; i ++ ) { smoothed Playhead Offset Us += playhead Offsets [ i ] / playhead Offset Count ; } } if ( needs Passthrough Workarounds ( ) ) { return ; } if ( system Clock Us - last Timestamp Sample Time Us >= MIN TIMESTAMP SAMPLE INTERVAL US ) { audio Timestamp Set = audio Track Util . update Timestamp ( ) ; if ( audio Timestamp Set ) { long audio Timestamp Us = audio Track Util . get Timestamp Nano Time ( ) / NUM ; if ( log . allow Verbose ( ) ) { log . v ( STRING + audio Timestamp Us ) ; } long audio Timestamp Frame Position = audio Track Util . get Timestamp Frame Position ( ) ; if ( audio Timestamp Us < resume System Time Us ) { audio Timestamp Set = BOOL ; log . w ( STRING + audio Timestamp Us + STRING + resume System Time Us ) ; } else if ( Math . abs ( audio Timestamp Us - system Clock Us ) > MAX AUDIO TIMESTAMP OFFSET US ) { String message = STRING + audio Timestamp Frame Position + STRING + audio Timestamp Us + STRING + system Clock Us + STRING + playback Position Us ; if ( fail On Spurious Audio Timestamp ) { throw new Invalid Audio Track Timestamp Exception ( message ) ; } log . w ( message ) ; audio Timestamp Set = BOOL ; } else if ( Math . abs ( frames To Duration Us ( audio Timestamp Frame Position ) - playback Position Us ) > MAX AUDIO TIMESTAMP OFFSET US ) { String message = STRING + audio Timestamp Frame Position + STRING + audio Timestamp Us + STRING + system Clock Us + STRING + playback Position Us ; if ( fail On Spurious Audio Timestamp ) { throw new Invalid Audio Track Timestamp Exception ( message ) ; } log . w ( message ) ; audio Timestamp Set = BOOL ; } } if ( is Latency Quirk Enabled ) { latency Us = Amazon Quirks . get Audio HW Latency ( ) ; } else if ( get Latency Method != null && ! passthrough ) { try { latency Us = ( Integer ) get Latency Method . invoke ( audio Track , ( Object [ ] ) null ) * NUM - buffer Size Us ; latency Us = Math . max ( latency Us , NUM ) ; if ( latency Us > MAX LATENCY US ) { log . w ( STRING + latency Us ) ; latency Us = NUM ; } } catch ( Exception e ) { get Latency Method = null ; } } last Timestamp Sample Time Us = system Clock Us ; } }
@ Override public boolean contains ( Object object ) { if ( object == null ) { return BOOL ; } for ( int i = NUM ; i < size ; i ++ ) { if ( object . equals ( elements [ i ] ) ) { return BOOL ; } } return BOOL ; }
public void close ( ) throws IO Exception { writer . close ( ) ; }
public static void substitute Properties ( Node node , Properties properties ) { Node child ; Node next = node . get First Child ( ) ; while ( ( child = next ) != null ) { next = child . get Next Sibling ( ) ; if ( child . get Node Type ( ) == Node . TEXT NODE ) { child . set Node Value ( Properties Util . substitute Property ( child . get Node Value ( ) , properties ) ) ; } else if ( child . get Node Type ( ) == Node . ELEMENT NODE ) { Named Node Map attributes = child . get Attributes ( ) ; for ( int i = NUM ; i < attributes . get Length ( ) ; i ++ ) { Node attribute = attributes . item ( i ) ; attribute . set Node Value ( Properties Util . substitute Property ( attribute . get Node Value ( ) , properties ) ) ; } substitute Properties ( child , properties ) ; } } }
@ Suppress Warnings ( STRING ) public Pseudo Function Selector ( String function Name , String expression ) { super ( Type . PSEUDO FUNCTION ) ; this . pseudo Function = ( Pseudo Function < E > ) lookup Pseudo Function ( function Name . trim ( ) ) ; this . expression = expression ; this . parsed Expression = pseudo Function . parse Expression ( expression ) ; }
public static String fix Query Mistakes ( String q ) { q = q . replace All ( STRING , STRING ) ; q = q . replace All ( STRING , STRING ) ; return q ; }
public byte [ ] read Bytes ( ) throws IO Exception { if ( ! parse Tag ( ) ) throw new Burlap Protocol Exception ( STRING ) ; String tag = sbuf . to String ( ) ; if ( tag . equals ( STRING ) ) { expect End Tag ( STRING ) ; return null ; } else if ( tag . equals ( STRING ) ) { sbuf . set Length ( NUM ) ; byte [ ] value = parse Bytes ( ) ; expect End Tag ( STRING ) ; return value ; } else throw expect Begin Tag ( STRING , tag ) ; }
public synchronized Utterance pend ( ) { Utterance utterance = null ; while ( list . size ( ) == NUM ) { try { wait ( ) ; } catch ( Interrupted Exception ie ) { return null ; } } utterance = ( Utterance ) list . remove First ( ) ; notify ( ) ; return utterance ; }
public void test Long Value Pos ( ) { String a = STRING ; Big Decimal a Number = new Big Decimal ( a ) ; long result = NUM ; assert True ( STRING , a Number . long Value ( ) == result ) ; }
public static Evaluation Result find Or Create ( Result Hierarchy hierarchy , Result parent , String name , String shortname ) { Array List < Evaluation Result > ers = Result Util . filter Results ( hierarchy , parent , Evaluation Result . class ) ; Evaluation Result ev = null ; for ( Evaluation Result e : ers ) { if ( shortname . equals ( e . get Short Name ( ) ) ) { ev = e ; break ; } } if ( ev == null ) { ev = new Evaluation Result ( name , shortname ) ; hierarchy . add ( parent , ev ) ; } return ev ; }
public static boolean is Running Java Web Start ( ) { boolean has JNLP = BOOL ; try { Class . for Name ( STRING ) ; has JNLP = BOOL ; } catch ( Class Not Found Exception ex ) { has JNLP = BOOL ; } return has JNLP ; }
public boolean is Connected ( ) { return connected . get ( ) ; }
private void try Schedule Action ( Runnable action ) { try { scheduler . submit ( action ) ; } catch ( Rejected Execution Exception e ) { } }
private static double score Sequence ( List < Lat Long > pts ) { Lat Long prev = pts . get ( pts . size ( ) - NUM ) ; Lat Long prevprev = pts . get ( pts . size ( ) - NUM ) ; double prev Angle = Math . atan 2 ( prev . lat - prevprev . lat , prev . lng - prevprev . lng ) ; double score = NUM ; for ( Lat Long pt : pts ) { double angle = Math . atan 2 ( pt . lat - prev . lat , pt . lng - prev . lng ) ; double diff = prev Angle - angle ; if ( diff > Math . PI ) diff -= Math . PI * NUM ; else if ( diff < - Math . PI ) diff += Math . PI * NUM ; if ( diff < NUM ) score += NUM ; else score += diff ; prev = pt ; prev Angle = angle ; } return score ; }
public void add Web App Debug Model Listener ( I Web App Debug Model Listener listener ) { synchronized ( private Instance Lock ) { web App Debug Model Listeners . add ( listener ) ; } }
public void reset Policy ( ) { m Preferences . put String ( PREF LAST RESPONSE , Integer . to String ( Policy . RETRY ) ) ; set Retry Until ( DEFAULT RETRY UNTIL ) ; set Max Retries ( DEFAULT MAX RETRIES ) ; set Retry Count ( Long . parse Long ( DEFAULT RETRY COUNT ) ) ; set Validity Timestamp ( DEFAULT VALIDITY TIMESTAMP ) ; m Preferences . commit ( ) ; }
public void simulate Method ( Soot Method method , Reference Variable this Var , Reference Variable return Var , Reference Variable params [ ] ) { String sub Signature = method . get Sub Signature ( ) ; if ( sub Signature . equals ( STRING ) ) { java lang Security Manager get Class Context ( method , this Var , return Var , params ) ; return ; } else if ( sub Signature . equals ( STRING ) ) { java lang Security Manager current Class Loader 0 ( method , this Var , return Var , params ) ; return ; } else if ( sub Signature . equals ( STRING ) ) { java lang Security Manager current Loaded Class 0 ( method , this Var , return Var , params ) ; return ; } else { default Method ( method , this Var , return Var , params ) ; return ; } }
public static boolean is File Exists ( final String path ) { if ( Text Utils . is Empty ( path ) ) { Log . e ( File Utils . class , STRING ) ; return BOOL ; } final File file To Check = new File ( path ) ; return file To Check . exists ( ) && ! file To Check . is Directory ( ) ; }
private List < Reference > create Signature References ( XML Signature Factory xml Sig Factory , List < String > reference Id List ) throws No Such Algorithm Exception , Invalid Algorithm Parameter Exception { List < Reference > result = new Array List < Reference > ( ) ; for ( String ref Id : reference Id List ) { if ( ref Id == null ) { continue ; } Reference ref = xml Sig Factory . new Reference ( STRING + ref Id , xml Sig Factory . new Digest Method ( Digest Method . SHA 512 , null ) , Collections . singleton List ( xml Sig Factory . new Canonicalization Method ( Canonicalization Method . EXCLUSIVE , ( C14 N Method Parameter Spec ) null ) ) , null , null ) ; result . add ( ref ) ; } return Collections . unmodifiable List ( result ) ; }
public boolean remove Network Connection ( Network Connection network Connection ) { return network Connections . remove ( network Connection ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; return result . elements ( ) ; }
protected Object convert Array ( Object value ) { return value ; }
public static String encode String ( String s ) { return new String ( encode ( s . get Bytes ( ) ) ) ; }
Grid Lucene File ( Grid Lucene Directory dir ) { this . dir = dir ; files Cnt . increment And Get ( ) ; }
public void add Attributes ( Attributes atts ) throws SAX Exception { int n Atts = atts . get Length ( ) ; for ( int i = NUM ; i < n Atts ; i ++ ) { String uri = atts . get URI ( i ) ; if ( null == uri ) uri = STRING ; add Attribute Always ( uri , atts . get Local Name ( i ) , atts . get Q Name ( i ) , atts . get Type ( i ) , atts . get Value ( i ) , BOOL ) ; } }
public synchronized void add Pan Listener ( Pan Listener listener ) { m Pan Listeners . add ( listener ) ; }
public synchronized long last Online Ago ( ) { return ( System . current Time Millis ( ) - last Online ) / NUM ; }
public double distance weighted ( Pla Point Float p other , double p horizontal weight , double p vertical weight ) { double delta x = v x - p other . v x ; double delta y = v y - p other . v y ; delta x *= p horizontal weight ; delta y *= p vertical weight ; double result = Math . sqrt ( delta x * delta x + delta y * delta y ) ; return result ; }
public Name Space swap ( Name Space new Top ) { Name Space old Top = ( Name Space ) ( stack . element At ( NUM ) ) ; stack . set Element At ( new Top , NUM ) ; return old Top ; }
public static List < String > classes Path ( ) throws File Not Found Exception , Loading File Exception { List < File > files = get Java Files ( ) ; List < String > paths = new Array List < String > ( ) ; for ( File file : files ) paths . add ( file . get Path ( ) ) ; return paths ; }
public static Number sub ( Number a , Number b ) { if ( is Floating Point ( a ) || is Floating Point ( b ) ) { return a . double Value ( ) - b . double Value ( ) ; } else { return a . long Value ( ) - b . long Value ( ) ; } }
public static Stream < String > words Of ( String text ) { require Non Null ( text ) ; return WORDS . split As Stream ( text ) ; }
public static Delete Participant [ ] load Delete Participants ( Refactoring Status status , Refactoring Processor processor , Object element , Delete Arguments arguments , I Participant Descriptor Filter filter , String [ ] affected Natures , Sharable Participants shared ) { Refactoring Participant [ ] participants = fg Delete Instance . get Participants ( status , processor , element , arguments , filter , affected Natures , shared ) ; Delete Participant [ ] result = new Delete Participant [ participants . length ] ; System . arraycopy ( participants , NUM , result , NUM , participants . length ) ; return result ; }
@ Override public int hash Code ( ) { int my Position = position ; int hash = NUM ; while ( my Position < limit ) { hash = hash + get ( my Position ++ ) ; } return hash ; }
public void print ( Char Sequence text ) throws IO Exception { int size = text . length ( ) ; int pos = NUM ; for ( int i = NUM ; i < size ; i ++ ) { if ( text . char At ( i ) == STRING ) { write ( text . sub Sequence ( pos , size ) , i - pos + NUM ) ; pos = i + NUM ; at Start Of Line = BOOL ; } } write ( text . sub Sequence ( pos , size ) , size - pos ) ; }
public void close Running App ( String device ID , String app package ) throws Interrupted Exception , IO Exception { cmd . run Command ( STRING + device ID + STRING + app package ) ; }
@ Android Only ( STRING ) public void test unwrap 05 ( ) { String host = STRING ; int port = NUM ; Byte Buffer [ ] bb A = { Byte Buffer . allocate ( NUM ) , Byte Buffer . allocate ( NUM ) , Byte Buffer . allocate ( NUM ) } ; Byte Buffer bb = Byte Buffer . allocate ( NUM ) ; SSL Engine sse = get Engine ( host , port ) ; try { sse . unwrap ( bb , bb A , NUM , bb A . length ) ; fail ( STRING ) ; } catch ( Illegal State Exception iobe ) { } catch ( Exception e ) { fail ( e + STRING ) ; } }
